| 档案编号| 作者| 提案时间 | 状态 |
|:----:|:----:|:----:|:----:|
|〔草案03〕| DemoHn | 2020-01-19| 已接受 |

## 简介

世上几乎所有的编程语言都支持数值运算。个中原因不言自明：计算机因数值计算而生。随着计算机硬件及架构的迭代，现代CPU支持两种数值运算：整数运算及浮点数运算，因而大部分编程语言中的「数值」大致对应两类：「整数」和「浮点数」。

采用浮点数用于小数的四则运算固然高效，然而并不精确：以 Javascript 为例， `0.1 + 0.2 = 0.30000000000000004` 而不是精准的 `0.3`。在大部分情况这并不是大问题：尤其是浮点数占尽优势的图形学方面，多一个像素少一个像素从视觉上来看并没有什么区别。

而在面向业务开发，尤其是和金融相关的需求上，这样的误差是不可接受的；因此 Zn 的数值一反常规，默认采用高精度小数（decimal），具体表现为以下两个方面：

1. 支持无限长度的整数
2. 精确表示有限位数的小数

## 数值整体设计方案

### 何为「小数」？

一个「小数」包括以下三个要素：
1. 符号S `(sign)`
2. 系数C `(coefficient)`
3. 幂E `(exponent)`

其中，S为0或1之整数，当 `S = 1` 时，这个数为负数；  
    系数 `C >= 0` ，须为整数，且并不限制其取值之上限（亦即其位数可以为无数位）；  
    E是一个 `int64` 型整数，其取值范围为 `-2^63 ~ 2^63-1`。   

一个「小数」的数值V `(value)` 可以用以下公式计算出来：
```
V = (-1) * S * C * 10^E
```

以下为叙述方便，我们采用 `(S, C, E)` 这样的三元组来描述一个「小数」：  
比如「小数」`23.5678` 可以用 `(0, 235678, -4)`表示；  
`-125.8E+8` 可以用 `(1, 1258, 7)` 表示。

> 按照以上定义，不难发现其实「整数」是「小数」的特殊情况： 当 `E >= 0` 时即是一个「整数」。故而以下将「整数」与「小数」合并称作「小数」。

### 定义一个「小数」

`Zn` 默认将一个数值型 token 解析成一个「小数」，而无需在前面或者后面添加其他符号。如以下语句：

```
令数值1，数值2为12.567
```
语句最后的 `12.567` 文本即被解析成 `(0, 12567, -3)` 的小数。

以下情况下也可以被解析成小数：

|  文本 |      数值     |   备注  |
| ------ | ------------- | --------- |
| 123456 | (0, 123456, 0)| 正常整数 |
| -12345 | (1, 12345, 0)| 前导 - 号 |
| +12345 | (0, 12345, 0)| 前导 + 号 |
| .12 | (0, 12, -2)|
| 0.0000 | (0, 0, -4)|
| 0129.8 | (0, 1298, -1) |
| 1.0000 | (0, 10000, -4) |
| -18.9E-7 | (1, 189, -8) |
| -18.9E+27 | (1, 189, 26) | 幂后面的系数前面一定要跟 + 号 |
| -18.9e+27 | (1, 189, 26) | 中间的 E 也可以是小写 |
| 125*10^12 | (0, 125, 12) | 中间只能写 `*10^`，`*9^` 是不支持的 |
| 125*^12 | (0, 125, 12) | 可以省略 `10` |

以下情况下会报错：

| 文本 | 错误原因 |
| ------ | ------------- |
| 0xEF | 目前还不支持16进制字符的表示 |
| 34. | 小数点后需要跟数字 |
| 23..3 | 多个小数点 |
| 132 3456 | 数字之间不能有空格 |
| 125*8^2 | 只支持 `*10^` |
| 128E923| 幂值部分需要加前导符号 `+` 或者 `-` |
| --123 | 前导符号只能有一个 |

同时，为了阅读方便，可以在数字与数字__之间__的任何位置添加 `_` 表示分隔，如下所示： `1_000_000_000`，其效果等同于 `1000000000`。

### 「小数」的四则运算
> 太长不看版：CASIO 的科学计算器是怎么做四则运算的，Zn 就是怎么做的。

#### 小数的精度对齐

设有两个小数: `D1 = (S1, C1, E1), D2 = (S2, C2, E2)`，一开始由于幂的不同，C1 和 C2 是不能直接运算的，需
先对其进行精度对齐操作，得到 `D1', D2'`。

在对小数进行加法及减法时，需要进行精度对齐，具体规则如下：
```
E1 == E2   =>  D1' = D1,  D2' = D2
E1 >  E2   =>  D1' = (S1, C1 *10^(E1-E2), E2),  D2'  = D2
E1 <  E2   =>  D1' = D1,  D2' = (S2, C2 * 10^(E2-E1), E1)
```

#### __加法 （X+Y）__

设有两个小数，经精度对齐后为: `D1' = (S1', C1', E1'), D2 = (S2', C2', E2')`

> 经过精度对齐后，须注意 E1' = E2'。

则求和 `D3 = D1' + D2'` 的方式如下：

```
当二个数值同号
S1 XOR S2 = 0   =>  D3 = (S1', C1'+C2', E1')

当二个数值异号
S1 = 0, S2 = 1  =>  D3 = ((C1' - C2') >= 0, ABS(C1' - C2'), E1')
S1 = 1, S2 = 0  =>  D3 = ((C2' - C1') >= 0, ABS(C2' - C1'), E1')
```

#### __减法 （X-Y）__

与加法类似，二个数需要经过精度对齐变换，得 `D1' = (S1', C1', E1'), D2 = (S2', C2', E2')`，
则求差 `D3 = D1' - D2'` 的方式如下：

```
S1 = 0, S2 = 0  =>  D3 = ((C1' - C2') >= 0, ABS(C1' - C2'), E1')
S1 = 0, S2 = 1  =>  D3 = (0, C1' + C2', E1')
S1 = 1, S2 = 0  =>  D3 = (1, C1' + C2', E1')
S1 = 1, S2 = 1  =>  D3 = ((C2' - C1') >= 0, ABS(C2' - C1'), E1')
```

#### __乘法 （X*Y）__

> 令人意外的是，计算乘法反而是最简单的，连精度对齐都不需要做。

求积 `D3 = D1 * D2` 的方式如下：

```
D3 = (S1 XOR S2, C1 * C2, E1 + E2)
```

#### __除法 （X/Y）__

> 除法涉及到默认保留精度的问题（也就是小数后保留N位）。比如说 `10 / 3 = 3.333333...`，除法的结果怎么样都是除不尽的。一般默认保留精度为8位有效数字-四舍五入。

设有两个小数: `D1 = (S1, C1, E1), D2 = (S2, C2, E2)`，计算 `X = D1 / D2` 的方法如下：

1. 首先给定 有效数字 M，并假设 adjust = 0
2. 当 `C1 < C2` 时，调整 D1 精度，使得 `C2 <= C1' <= C2 * 10`；`adjust += (E1' - E1) `  
当 `C1 >= C2` 时，调整 D2 精度，使得 `C2 <= C1' <= C2 *10`； `adjust -= (E2' - E2)`
3. `(C1' * 10^(M-1)) DIV C2'`，得 `q = Xq, r = Xr`
4. 若是 `Xr * 2 >= C2'` ， `Xq = Xq + 1`
5. X = (S1 XOR S2, Xq, E1 - (E2 + adjust))

示例： 当 `A = 1, B = 300` 时， `X = (0, 33333333, -11)`
当 `A = 2000, B = 500` 时， `X = (0, 40000000, -7)`


## 参考资料
1. http://speleotrove.com/decimal/decarith.pdf
2. https://github.com/SDL-Hercules-390/decNumber/blob/master/decnumber.pdf
3. https://reference.wolfram.com/language/tutorial/NumericalPrecision.html?source=footer