| 档案编号| 作者| 提案时间 | 状态 |
|:----:|:----:|:----:|:----:|
|〔草案05〕| DemoHn | 2020-06-09 | 已接受 |

## 简介

在 `rev.02` 的基础之上， `rev.03` 对于基本的语法结构进行更加细致的调整以丰富原有的功能。同时， 自`rev.03`起，Zn语言将制订标准语法文档以作参考。

`rev.03` 涉及到的调整主要有以下几点：

- 添加 `如果 ... 为 ...` 语句 [DONE]
- 添加 `以 ... 遍历` 语句（数组版及列表版） [DONE]
- 在 `每当` 语句中内置 `此之（继续）` 及 `此之（结束）` 语法 [DONE]
- 数字显示优化 [DONE]
- 方法前向定义 

## 修订内容

__1. 添加 `如果 ... 为 ...` 语句__


最早在 `rev.01` 中所使用的「如果」语句之语法如下所示：

```
CFG:
CondStmt  -> 如果  Expr  ：  [Stmts]
```

在大多数情况下，「如果」语句用来比较两个数值是否相等，如 `如果{此 数值 为 200}`。为了比较二个值是否相等还需要在变量前加上 `此` 字，实属不智。（当然 `此 A 为 B` 表示式主要是为了和 `A 为 B` 区分开来 -- 后者是赋值表达式）。

因此，我们引入 `如果 ... 为 ...` 语句，希望简写 `如果 此 A 为 B` ，其语法如下：

```
CFG:
CondStmt ->  如果 ExprA 为 ExprB ：  [Stmts]
```

注意：`如果 ExprA 为 ExprB` 的优先级要大于 `如果 Expr` 语句本身。诸如 `如果 A 为 B 为 C` 会被解析成 `如果 {此 A 为 {B 为 C}}`

> UPDATE: 事实上把 `为` 关键字变成比较关键字要更加靠谱一些。  
> UPDATE2：相比之下， `此 ... 为 ...` 语句就显得非常鸡肋了。对于 `如果` ，`每当` 语句而言，用 `如果 A 为 B` 效果更好；对于一般表达式，直接使用 `A 等于 B` 就可以了。

__2. 添加 `以 ... 遍历 ...` 语句__

此语句提供了一个方便途径遍历某一个数组/列表里的每一个元素（包括其索引），并针对每一个元素执行个中语句。此语句之效果可类比以下编程语言的类似语句：

```go
// golang
for k, v := range array {
    // ...
}
```

```javascript
// javascript
for (var a in array) {
    // ...
}
```

```php
// php
foreach ($array as $key => $val) {
    // ...
}
```

其基本语法有三种：

  1.  `遍历 〔数组/列表对象〕 ：  ⏎〔语句...〕`

第一种情况下，前面没有任何变量定义，「遍历」关键字后面仅为要被被遍历的对象。这个对象的类型限定为数组及列表，而其他类型会报错。遍历时会按照顺序得到对象的每一个元素以执行后面所跟的语句。如：

```zn
遍历【100，200，300，400】：
    （显示：此之索引，此之值）

注1:「
结果为：

0 100
1 200
2 300
3 400
」
```

`此之索引` 和 `此之值` 是针对此遍历作用域下的特殊属性。顾名思义，`此之索引` 指的是当前所取出的元素所对应的索引；而 `此之值` 指的是当前所取出元素所对应的值。`索引` 和 `值` 对于不同类型的遍历对象有着不同的含义，如下表所示：

| 遍历对象类型| 索引| 值| 备注 |
|-----|----|-----|----|
| 数组| 此元素在数组中的位置（比如 0,1,2）| 对应位置的元素的值（如a[0], a[1]） | 遍历时从0开始一直到最后一个元素 |
|列表| 某条键-值对所对应的键| 某条键-值对所对应的值| 遍历列表本质上是遍历其键-值对，遍历时并没有固定顺序（受 Golang 影响）|

  2.  `以 〔值〕 遍历 〔数组/列表对象〕 ：  ⏎〔语句...〕`

和 `1` 大致相同。不过鉴于 `此之值` 的写法实在是比较啰嗦，这里用 `以` 关键字前置于 `遍历`，而在后面 **声明** 一个变量名以存当前遍历所取出之元素值之用。值得注意的是，此变量名是在一个新的作用域所声明并赋值，不会影响父作用域上的变量值，就算两者同名，如下所示：

```zn
令V为0

以V遍历【20，40，60，80】:
    ...
    注1：历经4次循环，内层作用域的V值分别为20，40，60，80

注2：结束遍历后，外层作用域的V值仍然是0
```

  3.  `以 〔索引名〕 ， 〔值名〕 遍历 〔数组/列表对象〕 ：  ⏎〔语句...〕`

和 `1`, `2` 大致相同，不过在 `以` 关键字后面声明了两个变量，前者为 `索引`，后者为 `值`。

以下用例展示了如何使用 `遍历` 语句：

```zn
令分省人口表为【
    「广东」 == 11346，
    「福建」 == 3941，
    「山东」 == 10047，
    「浙江」 == 5737，
    「江苏」 == 8050，
    「黑龙江」 == 3773，
    「吉林」 == 2704，
    「辽宁」 == 4359 
】

注1：筛选出人口大于5000万的省份并显示其省份名称，最终给出大于5000万人口的省份数量

令总值为0
以省份，人口数遍历分省人口表：
    如果人口数大于5000：
        （显示：省份，「的人口数大于5000万」）
        总值为（X+Y：总值，1）

（显示：「人口数大于5000万的省份数有」，总值，「个」）
```

NOTE1: 实际上 `以 K，V 遍历 O` 可以等效理解为「以K作为当前索引及以V作为当前值而遍历对象O」 

NOTE2: 和 `每当`的情况类似，`遍历`语句亦支持 `此之（结束）` 或者 `此之（继续）`以控制遍历流程。

__3. 在 `每当` 语句中内置 `此之（继续）` 及 `此之（结束）` 语法__

在很多情况下，我们需要中途中断某个循环流程 (break) 或者重新走到下一个循环流程 (continue)。在大部分编程语言中，上述两个功能都是靠在语法上添加 `break` 及 `continue` 关键字来实现。而出于节省关键字的考虑（以及「继续」和「结束」完全可以作为某个方法名的开头），Zn 语言准备以「特殊方法」的形式来代替 `break` 和 `continue` 这两个关键字。

「特殊方法」指的是在某个作用域下限定执行的 Zn 语言内置方法。其格式为 `此之（〔方法名〕：〔参数〕...）` 。其中 `此之` 作为关键词代表着此方法所需要指定的作用域，如下所示：

```zn
每当A大于0：      <-- 外层，作用域A
    ...
    此之（结束）  --> 只对外层作用域A有效，将会跳出外层循环

    每当B小于0：  <-- 内层，作用域B
        ...
        此之（结束） --> 只对内层作用域B有效，将会跳出内层循环
```

- `此之（结束）`

  其效果与 `break` 同，将会跳出当前作用域下的循环。注意此语句仅在 `每当` 及 `遍历` 语句有效。
  
  举个例子：
  ```zn
  每当真：
      〔语句1〕
      〔语句2〕
      如果A大于0：
          此之（结束）

      〔语句3〕
      〔语句4〕
      ...
  
  〔外层语句1〕
  ```

  正常情况下，每一次循环都会依序执行`〔语句1〕`，`〔语句2〕`，`〔语句3〕`，`〔语句4〕`，而后再从头开始执行`〔语句1〕`，如此循环往复。而当A大于0时，`此之（结束）`方法被执行，之后的`〔语句3〕`，`〔语句4〕`将不再被执行而直接执行 `〔外层语句1〕`


- `此之（继续）`
 其效果与 `continue` 同，将会跳出当前作用域下的循环。注意此语句仅在 `每当` 及 `遍历` 语句有效。
  
  举个例子：
  ```zn
  每当真：
      〔语句1〕
      〔语句2〕
      如果A大于0：
          此之（结束）

      〔语句3〕
      〔语句4〕      
      ...
  
  〔外层语句1〕
  ```

  正常情况下，每一次循环都会依序执行`〔语句1〕`，`〔语句2〕`，`〔语句3〕`，`〔语句4〕`，而后再从头开始执行`〔语句1〕`，如此循环往复。而当A大于0时，`此之（继续）`方法被执行，之后的`〔语句3〕`，`〔语句4〕`将直接跳过而直接从头执行 `〔语句1〕`


__4. 数字显示优化__

> NOTE: 数字显示的方法具体参考了[Javascript的相关实现](https://2ality.com/2012/03/displaying-numbers.html)

在 Zn 语言中，一个数可以用以下方法表示：

```
X = M *10^ (P - D)
```

- `M` 表示这个数的整数部分 （即 `X.co`）
- `P` 表示这个数的小数点位置
- `D` 表示M的位数（即 `len(X.co)`）

值得注意的是，一般M和D的值是已知的，P的值可以通过X的`exp`值推导出来。

故目前有四种情况：

- `0 < D <= P <= 18`： 不用小数点，后面按照情况添0 （如 `12345000`）
- `0 < P <= 18, P < D`: 正常小数，小数点的位置在第 `P` 个数后面（如 `123.456`, `D=6, P=3, X=123456*10^(3-6)`）
- `-6 < P <= 0`：前导0，在`0.`后面补上`P`个0 (如 `0.0023`, `D=2,P=-2,X=23*10^(-2-2)`)
- `P <= -6 or P > 18`： 使用科学计数法：（如`4.56*10^-8`），其中前面的数在小数点后面至多8位，而 `*10^` 后面的值即是 `P-1`

__5. 方法前向定义__

严格意义上讲，这应该是叫作 [Variable Hoisting](https://www.w3schools.com/js/js_hoisting.asp)，最早来源于 `Javascript`， 原本概念里这是指将变量及函数的定义放到作用域的最前面。

比如以下js代码就用到了 `Variable Hoisting`：

```js
helper(); // 此时 `helper` 还没有定义

function helper() {
    console.log("Hello World"); 
}
```

执行代码，会得到结果 `Hello World` 而不是报错。其原因就在于 `javascript` 在执行此程序的过程中会预先将 `helper` 函数的定义挪到最前面来执行了。也就是说实际代码顺序是这样的：

```js
function helper() {
    console.log("Hello World");
}

helper();
```

这个特性最大的好处在于可以将主逻辑写在前面，函数定义放后面以突出主题。`Zn` 语言亦计划支持方法前向定义以方便使用。

大约是这样，每读取到一个block，先扫描个中有没有 `如果` 语句，若是有的话就预先解析之；而后第二次执行时即可直接跳过对于 `如果` 语句的解析。