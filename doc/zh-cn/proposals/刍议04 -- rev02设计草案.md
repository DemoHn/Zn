| 档案编号| 作者| 提案时间 | 状态 |
|:----:|:----:|:----:|:----:|
|〔刍议04〕| DemoHn | 2020-02-18 | 已接受 |

## 简介

前面已经完成了 [rev.01](https://github.com/DemoHn/Zn/blob/master/doc/rev01.md) 的设计，接下来继续对Zn语言进行扩展。

## 语言文法

__1. 添加「列表」相关文法__

在 `rev.01` 中已有「元组」的定义：
```
CFG:
Array -> 【   ItemList   】
      -> 【   】
ItemList ->   Expr
         ->   Expr1，Expr2，...

如：【1，2，3】
```
rev.02 计划引入 「列表」的概念。

> 所谓「列表」是指一系列键-值对的组合，和 Java 中的 `HashMap` 类似。

列表的语法和「元组」相似，外层都用 `【 】` 括住，里面定义一系列键-值对。每一个键-值对都可以用以下两种语法表示：
```
1)  〖索引名〗 == 〖对应值〗 
2)  〖索引名〗 ⟺〖对应值〗
```
左边的〖索引名〗只允许「整数」及「文本」类型的值（也就是说变量是不支持的）；  
右边的〖对应值〗可以是一个任意表达式；  
中间的 `==` 或者 `⟺` 表示「两者对应」；  
每个键值对之间用 `，` 隔开。和「元组」类似，「列表」对内里键-值对的缩进不作要求。

一个合法的「列表」如下所示：

```
令历史年表为【
    「周」 == -1048，
    「夏」 == -2345，
    「元」 == 1024，
    「清」 == 1748
】
```

所以更新后的上下文无关文法为：
```
MAP_SIGN ->  ==
        -> ⟺ 
Array ->  【 ItemList  】
      ->  【    】
      ->  【  MapList  】
      ->  【    MAP_SIGN    】

ItemList ->   Expr
         ->    Expr1，Expr2，...

MapList -> Map
        -> Map1， Map2，...

Map -> Number   MAP_SIGN   Expr
    -> String   MAP_SIGN   Expr
``` 

__2. 对「列表」、「元组」取值__

「元组」的索引从0开始数起：比如说对于元组`【2，4，6，8，10】`，它的 `第0个值` 为 2，它的 `第1个值` 为 4。

对于一个确定索引（也就是第N个值），我们可以通过下面的语法来取得这个索引所对应的值：
```
〖元组〗 #  〖数值〗
```
比如说 `【2，4，6，8，10】#3` 对应的意思就是「元组的第3个值」。根据上面的准则，这个表达式应该返回 `8`。唯须注意：这种写法的数值一定是一个固定的数，不接受变量。

同时对于索引值是个变量，可以通过以下语法确定所对应的值：
```
〖元组〗 #{  〖表达式〗  }
```

比如说如下代码：
```
令列索引为1
【2，4，6，8，10】#{ 列索引 }
```
这里的 `列索引` 为1，所以上式执行时等同于 `【2，4，6，8，10】#1`，结果返回4。

对于「列表」，则不仅支持前述 `〖元组〗 #  〖数值〗` 的语法，还支持 `〖元组〗 #{  〖表达式〗  }` 的语法及 `〖元组〗 #  〖文本〗` 的语法， 如下所示：

```
令汉字-数字表为【
    「一」 == 1，
    「二」 == 2，
    「四」 == 4，
    「八」 == 8 
】

汉字-数字表#{「一」}          注1：=> 1

令文字为「八」
汉字-数字表#{文字}            注2：=> 8
```

其上下文无关语法为：
```
VarAssignExpr  ->  AssignableExpr VarAssignExpr'                   // 替换 BasicExpr -> AssignableExpr
VarAssignExpr'  ->  为 AssignableExpr                                      // 替换 BasicExpr -> AssignableExpr
                 ->

AssignableExpr  ->  BasicExpr AssignableExpr'

AssignableExpr'  ->   #    Number    AssignableExpr'    
                 ->   #{    Expr    }    AssignableExpr'
                 ->   
```

__3. 定义「方法」__

「方法」的本义，就是「完成某一件事的过程」。在不同编程语言当中，它有着不同的名字：如 `procedure`, `sub`, `function`, `func`。

一个方法由以下几个要素组成：

1. 方法名
2. 输入参数列表（形参）
3. 执行方法的语句
4. 返回值

所以一个「方法」的格式可以简单如下如示：
```
如何〖方法名〗？
    已知〖参数1〗，〖参数2〗，...
    〖语句〗
    ....
    返回〖表达式〗
```

以下例子定义一个名为「计算利息」的方法：
```
如何计算利息？
    已知本金，月息，月份数
    返回（X*Y：本金，月息，月份数）
```

> 注1：如果在一个方法里不需要定义参数列表，那么「已知」语句是可以省略的。

> 注2：确定一个方法的返回值有以下三个顺序：
>  1) 执行「返回」语句后面所跟的表达式
>  2) 最后一个执行的表达式的值
>  3) 以上皆无，返回 ‹空›

其上下文无关语法如下：
```
FuncDeclareStmt   ->  如何    ID    ？
                  ..      FuncDeclareBlock

FuncDeclareBlock   -> ParamStmt Statements...
                  -> Statements

ParamStmt  -> 已知    ID1，ID2，...
```

__4. 以 ... 执行方法__

一般情况下，调用一个方法如下所示：
```
（连缀：「小明的港币资产为#1 HKD，美元资产为 #2 USD」，100，200）
```
可以见到，在方法名后面依次排列着各个传入参数。

而如果把第1个参数调到函数名之前，如下所示：
```
以「小明的港币资产为#1 HKD，美元资产为 #2 USD」（连缀：100，200）
```
这个方法调用实际上与上面相同，不过看起来语句会变得更加通顺！

「以 ... 执行方法」的一般语法如下：
```
以 〖参数1〗（〖方法名〗：〖参数2〗，〖参数3〗，... ）
```

修订后的上下文无关语法：
```
CallExpr  ->  以  Expr （  ID  ：  ParamList  ）
          -> （ ID  ： ParamList ）
```