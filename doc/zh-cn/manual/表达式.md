# 表达式

表达式是语句的一部分，在执行这部分逻辑后能够得到对应结果值。举个例子，在语句 `令价格 = 2 + 3` 中，等号右边的 `2 + 3` 即是一个表达式，其对应的结果值是 `5`。本章将详细讲述 zinc 中支持的表达式的语法定义以及使用方法；

## 基础表达式

基础表达式是构成一个完整表达式的基本单元；在基础表达式之上还可以添加括号、花括号等词素 (token) 以构成更加复杂的表达式。在大部分情况下，基础表达式可以「独木成林」，亦即一个词素 (token) 即可构成一个表达式；基础表达式可分为以下几种类型：

**1. 标识符**

当一个标识符作为变量名使用时，它即代表了这个变量；同时这个表达式的结果值即是其对应变量的值。

比如事先定义一个名为「价格」的变量，并设置其值为数值 `19.9`；在语句 `（显示：价格）`中，冒号后面的 `价格` 标识符即作为变量名使用，其结果值亦是数值 `19.9`；而冒号前面的 `显示` 标识符作为方法名使用，因此 `显示` 在此处并非表达式。


**2. 数值及文本**

数值、文本皆为 zinc 的基本类型，同时它们也是一个单独的词素 (token)；程序在解析这些词素时会直接将它们当作一个表达式，其结果值即为此词素所代表的值；

如在语句 `（显示：125e-2）` 中，冒号后面的 `125e-2` 就是一个数值表达式，其值为 `1.25`，同理在语句 `（显示：「上是中国同」）` 中 `「上是中国同」` 是一个文本表达式，其值为文本 `上是中国同`，恰好五个中文字符。

> ✉️ 数值、文本的格式可以参见「文本结构」一章。

**3. 列表和字典**

列表 (list) 、字典 (dict) 亦是 zinc 的基本类型，但是在构成表达式时结构时稍显复杂一些；同理，表达式的结果值即是此元素所代表的值；

**列表表达式**的 BNF 语法如下所示：

```
‹列表表达式›   ::=  【  】
               |  【  ‹表达式›  [、  ‹表达式›]+  】
```

试举数例说明：

```zn
令空列表 =【】    注1：等号右边即是一个表达式，其值为「长度为0的空列表」
令十内质数列表 =【2、3、5、7】
令复合列表 = 【【“一”、“二”】、【“三”、“四”】】
```

**字典表达式**的 BNF 语法如下所示：

```
‹字典表达式›   ::=  【  =  】               
               |  【  ‹键值对›  [‹键值对›]+  】

‹键值对›      ::=  'ID  =  ‹表达式›
               |  '文本  =  ‹表达式›
               |  '数值  =  ‹表达式›
```

试举数例说明字典表达式：

```zn
令简码字典 =【
    G = “一”
    F = “地”
    D = “在”
    S = “要”
    A = “工”
】
令空字典 =【=】
令单行字典 = 【H = “上”，J = “是”，K = “中”，L = “国”，M = “同”】
```

你可能已经注意到，列表表达式和字典表达式的头尾都是`【` 和 `】`；因此从语法上区分这两者只能通过中间的内容，区分方法如下：

  - 如果中间没有内容，则判断它为 _空的列表_
  - 如果中间只有一个 `=`，则判断它为 _空的列表_
  - 如果中间有至少一个表达式，且表达式中存在 `=`，则优先按照 _字典表达式_ 匹配
    - 诸如 `【价格 = 3】`，会优先认为是 _字典表达式_ ，而不是一个包含了 `价格 = 3` 的赋值表达式的 _列表表达式_
  - 如果表达式之间用 `、` 分隔，则认定其为 _列表表达式_ ；_字典表达式_ 中每个键值对之间要么用换行符分隔，要么用 `，` 分隔
    - `【1、2、3】` 即是合法的 _列表表达式_ ，因为里面的各个表达式之间用 `、` 分隔
    - `【价格 = 3、数量 = 5】` 不是合法的语法，因为前面先当作 _字典表达式_ ，而后面又出现了顿号，因此是不符合语法要求的

## 给变量赋值

给变量赋值是 zinc 的基本操作 —— 将计算好的值通过赋值的方式传递给指定的变量是操纵变量，进而实现各种复杂逻辑的主要方式。我们可以通过赋值运算符（`为` 或者 `=`）来实现。

其基本格式为：`‹待赋值变量› 为 ‹表达式›`  或者 `‹待赋值变量› = ‹表达式›`，具体流程即是将**右边**的表达式的值传递给**左边**的待赋值变量。试举数例以阐明其功用：

**1. 自增数值**

```zn
令成本累计 = 0，生产成本 = 25.8，海运成本 = 4.2

成本累计 = 成本累计 + 生产成本
成本累计 = 成本累计 + 海运成本
```

**2. 设置数组/列表的某个元素**

```zn
令地名组 =【“广州”、“深圳”、“香山”、“佛山”】
注1：将“中山”这个文本值传给「地名组」中的第3个元素 - 自此之后「地名组」的值即是 【“广州”、“深圳”、“中山”、“佛山”】
地名组#3 = “中山”

令车牌/地名表 =【
    “粤A” = “广州”
    “粤B” = “深圳”
    “粤L” = “东莞”
    “粤S” = “东莞”
】
注2：将“惠州”这个文本值传给「车牌/地名表」变量中对应「粤L」的位置
车牌/地名表#“粤L” = “惠州”
```

**3. 获取方法的结果**

```zn
如何转换英寸？
    已知厘米值
    输出厘米值 / 2.54

令厘米值 = 以“25.4”（转换数值）

令英寸值 = （转换英寸：厘米值）  // 「英寸值」变量值为10
```

**4. 修改对象的属性**

```zn
定义名片：
    其号码 = “10086”
    其名字 = “小明”

令小明成为（名片）

小明的名字 = “黄小明”  // 将“黄小明”文本传入到「小明」的「名字」属性中
```

## 表达式之间的运算符

表达式与表达式之间可以通过运算符进行运算；运算符通常夹在两个表达式中间，在执行时按照一定的优先级进行计算，得到新的表达式。

概括来说即是：`‹表达式1›  ‹运算符›  ‹表达式2›  ->  ‹新表达式›`；比如 `1 + 2` 即是将左边的 `1` 和 右边的 `2` 通过中间的 `+` 进行运算，最后得到结果。

以下详细介绍 zinc 所支持运算符的使用方法。

**四则运算：加、减、乘、除**

如果左右两个表达式的类型都是数值，那么两者之间可以进行加、减、乘、除等四则运算，就像我们在小学时期学过的数学表达式一样。各个运算所使用的运算符如下所示：

| 运算方法 | 表达式 | 示例 | 注意事项 |
|---------|-------|------|-------|
|  加法  | `+`  | `成本 + 5` | __运算符前后要加空格！！__ |
|  减法  | `-`  | `利润 - 3.7` | __运算符前后要加空格！！__ |
|  乘法  | `*`  | `销售额 * 0.25` | __运算符前后要加空格！！__ |
|  除法  | `/`  | `回款 / 5` | __1. 运算符前后要加空格 2. 被除数不能为0__ |

> ⚠️ 尽管 zinc 秉承着「非必要不加空格」原则，但是在输入运算表达式时，运算符前后**必须要加上空格**；这是因为 `+ - * /` 本身是可以作为标识符的一部分的，如果不加空格，诸如 `价格/2` 本身是会当作标识符本身而出现不符合预期的结果的！

四则运算符是可以连起来一直执行的，比如 `1 + 2 + 3 + 4 + 5 + 6 - 7` 是可以正常执行的（结果是`14`）；同时四则运算遵循「先乘除，后加减」的原则，优先执行乘除运算，再执行加减运算，比如 `3 + 5 * 7` 就是先执行 `5 * 7` 的表达式，得到 `35` 的结果后再和 `3` 相加，最后得到 `38`。

**逻辑运算：「且」**

「且」运算符用于同时比较两个条件是否都为真，如果两个条件都为真，则整个条件表达式的结果也为真。举个例子，如果我们要判断一个人是否符合做网约车司机，我们即可以使用「且」运算符连接两个条件：

```zn
年龄 > 18且会开车
```

其中「年龄 > 18」表示这个人的年龄大于18岁，变量「会开车」表示这个人是否会开车，如果「年龄 > 18」的值为`真`，而「会开车」的值也为`真`，则整个条件表达式的结果为`真`。

「且」运算符的真值表如下所示：

| 表达式1 | 表达式2 | 结果 |
|------|-------|-------|
| `真` |  `真`  | `真` |
| `真` |  `假`  | `假` |
| `假` |  `真`  | `假` |
| `假` |  `假`  | `假` |

**逻辑运算：「或」**

除了「且」运算符外，「或」用于比较两个条件中是否至少有一个为真；如果**至少有一个**条件为真，则整个条件表达式的结果也为真。举个例子，假设某学校的录取条件是英语成绩达标（雅思、托福均可），我们即可使用「或」运算符连接两个条件：

```zn
雅思 >= 6.5或托福 > 105
```

只要「雅思 > 6.5」表达式为`真`，或者「托福 > 105」表达式为`真`，整个条件表达式的结果为`真`。

「或」运算符的真值表如下所示：

| 表达式1 | 表达式2 | 结果 |
|------|-------|-------|
| `真` |  `真`  | `真` |
| `真` |  `假`  | `真` |
| `假` |  `真`  | `真` |
| `假` |  `假`  | `假` |

> 和其他关键字一样，`且` 和 `或` 关键字前后都不用加空格区分。

**比较运算符**

比较运算符是用来比较两个值之间的关系的。通常来说，比较运算符会返回一个逻辑值，即 `真` 或 `假`。

目前系统支持共 6 种比较运算符，如下所示：

| 运算符  | 功能 |
|-----|-----|
| `==` （`等于`）| 检查A是否等于B |
| `/=` （`不等于`）| 检查A是否不等于B |
| `>` （`大于`）| 检查A是否大于B |
| `<` （`小于`）| 检查A是否小于B |
| `>=` （`不小于`）| 检查A是否大于或者等于B |
| `<=` （`不大于`）| 检查A是否小于或者等于B |

括号内的中文是对应运算符的关键字，两者完全等价。也就是说，`A == B` 和 `A等于B` 是一个意思。

目前，我们只支持**数值**类型的比较，诸如**文本**、**列表**类型的比较请使用其他方法。

比较运算符的使用方法很简单，只需要把要比较的值放在运算符两侧即可。比较运算符的结果是一个逻辑值，可以用于各种逻辑判断。

**运算符的优先级**

运算符的优先级决定了表达式中运算执行的先后顺序。当一个表达式中包含了多个运算符时，我们先按照优先级高低依次执行，高优先级的表达式的执行结果即作为低优先级表达式的操作数；相同优先级的表达式即按照**从左往右**的顺序依次执行。

运算符的优先级列表如下所示，数字越大表示优先级越高：

<table>
  <thead>
    <tr>      
      <th align="center">优先级</th>
      <th>运算符类型</th>
      <th>运算符</th>      
      <th>备注</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td align="center">八级</td>
      <td>花括号组合</td>
      <td><code>{ }</code></td>
      <td><i>使用方法见下一节</i></td>
    </tr>
    <tr>
      <td align="center">七级</td>
      <td>访问列表元素</td>
      <td><code>#</code></td>
      <td><code>【10、20】#1 + 1</code> 得到 11 而不是 20</td>
    </tr>
    <tr>
      <td align="center" rowspan="2">六级</td>
      <td>乘法</td>
      <td><code>*</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>除法</td>
      <td><code>/</code></td>
      <td>乘除是并列的</td>
    </tr>
    <tr>
      <td align="center" rowspan="2">五级</td>
      <td>加法</td>
      <td><code>+</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>减法</td>
      <td><code>-</code></td>
      <td>加减是并列的</td>
    </tr>
    <tr>
      <td align="center">四级</td>
      <td>赋值</td>
      <td><code>为</code>，<code>=</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="6">三级</td>
      <td>相等（数值比较）</td>
      <td><code>等于</code>，<code>==</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>不相等（数值比较）</td>
      <td><code>不等于</code>，<code>/=</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>大于（数值比较）</td>
      <td><code>大于</code>，<code>&gt;</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>小于（数值比较）</td>
      <td><code>小于</code>，<code>&lt;</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>大于等于（数值比较）</td>
      <td><code>不小于</code>，<code>&gt;=</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>小于等于（数值比较）</td>
      <td><code>不大于</code>，<code>&lt;=</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center">二级</td>
      <td>逻辑与</td>
      <td><code>且</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center">一级</td>
      <td>逻辑或</td>
      <td><code>或</code></td>
      <td></td>
    </tr>
  </tbody>
</table>

**用花括号组合**

在某些情况下，我们希望程序能够优先执行某一部分组合，即使正常情况下它们还没到这个优先级；这个时候我们即可以在需要优先执行的表达式和运算符之间加上一对花括号 `{` `}`；其 BNF 语法如下所示：

```zn
‹基础表达式›   ::=  {  ‹表达式›  }
```

举个简单的例子：我们都知道四则运算遵循「先乘除，后加减」的原则，因此表达式 ` 2 + 3 * 5` 的结果应是数值 `17`。而如果加上花括号，则表达式 `{2 + 3} * 5` 中优先执行花括号内的组合，得到 `5`，再进行乘法，得到结果 `25`。

## 方法调用表达式

方法调用即是通过传入指定的参数和方法名称，执行方法内预先编写的逻辑，并输出相应的结果值。方法调用的形式非常灵活多样，如下所示：

**1. 直接调用方法**

直接调用方法的语法格式如下：

```
‹方法表达式'›   ::=  （  ‹方法名›  ）
                |  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

> 和其他编程语言不同，这里的括号会把方法名以及对应参数全部包进去；这种设计主要出于分词考虑：如果像其他一样做成 `方法名（参数...）` 的话，一来格式上会产生疏离；二来方法名会和前面的对象产生混淆，造成无法分词的现象。

举个例子，假设我们事先设计了一个名为「求积」的方法，这个方法接受两个数值，并得到两者的乘积（亦即表达式的结果值为两者乘积）；现在要求 `4` 和 `9` 的乘积，就可以用 `（求积：4、9）` 来完成任务；

如果在调用某个方法时不需要传入参数，那么连冒号都可以不用了，直接在括号里写上方法名即可，如 `（结束）`。

**2. 调用元素对应的方法**

在 Zn 程序中，所有的变量值都属于 `元素` 类型，继而每一个元素都自带其对应的方法；这里的方法与面向对象语言中，对象的「方法」有异曲同工之妙。其语法格式如下：

```
‹方法表达式'›   ::=  以  ‹表达式›  （  ‹方法名›  ）
                |  以  ‹表达式›  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

比如说我们要求「价格」变量向上取整之后的值，就可以这么写：`以价格（向上取整）`。

**3. 得到结果的两种形式**

在调用完方法后，下一步即是获取对应的结果。获取结果的第一种形式即是通过赋值语句将结果传给某个变量，比如 `结果 = （求积：4、9）`；第二种形式即是使用 `得到` 关键字，将结果传给 `得到` 后面的变量，其语法如下所示：

```
‹方法表达式›   ::=  ‹方法表达式'›  得到  'ID
```

这种语法设计的好处即是让语句更加通顺，更加符合中文自身的语法，试举数例：

```zn
以价格（向上取整），得到显示价格
（求积：4、9），得到结果
```

> 注1：这里的逗号 `，` 是可选项，可以加上也可以省略。  
> 注2：`得到` 关键词后的变量将会自动进行声明，再进行传值。 

**4. 方法的链式调用**

在调用变量对应的方法时，我们注意到 `以` 关键词后面也是个表达式；所以从理论上讲 `以以以以X（方法1）（方法2）（方法3）（方法4）` 这样诡异的表达式也是成立的。这个语句的具体执行逻辑是这样的：
  - 先执行 `以X（方法1）`，其结果假设为 `X1`
  - 将X1作为变量执行 `以X1（方法2）`，得到 `X2`
  - 将X2作为变量执行 `以X2（方法3）`，得到 `X3`
  - 将X3作为变量执行 `以X3（方法4）`，得到最终结果 `X4`

可以看到，这里看似俄罗斯套娃的语法实际上就是链式调用，上一个方法得到的值作为变量套到下一个方法中，最终得到结果。

为了避免上述诡异的语法产生，同时方便阅读，此处特地设计了一个链式调用的语法：

```
‹链式调用方法›   ::=  以  ‹表达式›  （  ‹方法名›  ：  ‹参数›  ） [、  （  ‹方法名›  ：  ‹参数›  ）]
```

因此，上面的语法即可改写成以下形式：

```zn
以X（方法1）、（方法2）、（方法3）、（方法4），得到X4
```

## 获取元素的属性

所有的变量都是对象，都有其对应的属性；我们可以通过对应的表达式获取变量的某个属性；获取属性的语法如下所示：

```
‹属性表达式›   ::=  ‹表达式›  [之  |  的]  'ID
```

`之` 或 `的` 从语法上没有任何区别，在实际使用时可以凭借表达式以及属性的名称的通顺程度来决定使用哪个关键字。

同时，在部分确定上下文的情况下（比如说在 `定义` 语句下），我们可以用 `其` 关键字来指代指定的元素，其语法如下所示：

```
‹属性表达式›   ::=  其  'ID
```

## 获取列表/字典的成员

对于列表/字典类型的变量而言，我们能够通过对应的索引获取到这个变量对应的某个值；
  - 如果是列表类型，可以通过索引获取其第 N 个元素的值 （**N从1开始**）
  - 如果是字典类型，可以通过索引获取某个键名下的值

其语法大致如下所示：

```
‹成员表达式›   ::=  ‹表达式›  #  '数值
               |  ‹表达式›  #  '文本
               |  ‹表达式›  #  {  ‹表达式›  }
```

试举数例：

```zn
【2、4、6、8、10】#2     注1：获取列表的第2个元素，结果为4
【T=“和”，R=“的”，E=“有”】#E   注2：获取字典中“E”对应的值，结果为“有”
【2、4、6、8、10】#{5 - 3}     注3：获取列表的第2个元素，结果为4
```