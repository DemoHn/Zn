# 语句 

在 zinc 语言中，语句 (statement) 是用来告诉计算机需要执行什么操作的一种表达方式 -- 比如「循环语句」即是要求计算机重复执行某段代码；「判断语句」即是根据不同的条件执行不同逻辑。语句是构成一个程序的基本要素，程序运行时，会按照顺序解析并执行一条条语句。

## 语句的基本结构

**一条语句的组成**

一条完整语句是由一个或多个元素（关键词/标识符/数值等）拼在一起的，所谓「遣词造句」即是此意。当然，不是随便几个关键词拼在一起就是一条合法的语句，它需要遵循一定的语法才能被程序正确执行。

比如 `令年龄 = 20` 即是一条完整的合法语句，它是由 `令`，`年龄`，`=`，`20` 这四个词素拼在一起的；`令令年龄 = 20` 不是一条完整合法的语句，因为它不符合语法规范，在第一个 `令` 后面又加了一个 `令`。

> 「非必要不加空格」原则：关键词和变量之间不需要加空格以区分，我们完全可以像写一句话一样把一条语句写出来。

**语句块的定义**

数个语句通过一定的分隔方式（换行或者分号，见下一节）拼在一起即形成了语句块，同一个语句块内缩进（简单来说就是每行前面的空格数）应保持一致。举个例子：

```zn
如果条件为真：
    令年龄 = 20
    令姓名 = “小明”
    令身高 = 175
```

上面程序中第2、3、4行语句形成了一个语句块，这个语句块即代表了「当条件为真」时要执行的所有语句。

**语句之间的分隔**

语句与语句需要加以分隔，否则会抛出语法错误 -- 比如 `令年龄 = 20` 是一条完整的语句， `令姓名 = “小明”` 也是一条完整的语句；但是将两个语句直接连起来：`令年龄 = 20 令姓名 = “小明”` 即是不合法的，会抛出语法错误。

分隔语句有两种方式：分号（`；`）或者换行。一般情况下，推荐使用换行的方式，这样显得程序更加清晰直观，同时也省去了打分号的麻烦。上面的两条语句即可以通过换行的方式将其写成两行：

```zn
令年龄 = 20
令姓名 = “小明”
```

如果希望将多条语句放在一行，那就在语句之间加一个分号（`；`），如下所示：

```zn
令年龄 = 20；令姓名 = “小明”
```

## 声明变量语句

变量是用于存储值的容器。在 zinc 中，所有的变量需要「先声明，后赋值」—— 先告诉编译器「我要创建这个变量」，再给予这个变量一个初始值。声明变量语句以单字 `令` 开头，后面跟上要声明的变量名称以及其对应的初始值。

> 注意：所有变量在声明的同时都要给予初始值，诸如 `令某变量` 这样的光声明不赋值的做法是不符合语法要求的。

**基本语法**

声明语句支持「单行语法」和「多行语法」；两者皆以 `令` 关键字开头，区别在于是否可以同时声明多行变量。


「单行语法」的基本结构如下：

```
令 [‹变量组› ‹声明运算符› ‹初始值›]+
```

最常见的例子即是 `令马匹 = “千里马”`。在这里我们声明了一个名为“马匹”的变量，并将其赋予了一个文本值 “千里马”。

`‹变量组›` 可以是单个变量，也可以是多个变量，用顿号 （`、`）隔开，因此我们也可以在一行里面同时声明多个变量，而同时给予这些变量相同的值，如下所示：

```zn
令白马、黑马、红马、黄马 = “千里马”
```

这样就同时声明了四个变量，且它们的初值都是“千里马”。



「多行语法」的基本结构如下：

```
令：
    [‹变量组› ‹声明运算符› ‹初始值›]+
    [‹变量组› ‹声明运算符› ‹初始值›]+
    ...
```

多行语法也是以 `令` 字开头，后面跟着一个冒号（`：`），而后另起一行空四格写上要声明的变量。举个例子：

```zn
令：
    白马 = “千里马”；老牛 = “老黄牛”
    黑马 = “宝马”
    红马、绿马、黄马 = “健康马”；公鸡、母鸡 = “走地鸡”
```

**声明运算符**

目前 zinc 共支持三种声明运算符：

1. 赋予新值：`为` 或者 `=`

    `令白马 = “千里马”` 和 `令白马为“千里马”` 两者是等价的。

2. 赋予新值，且不能更改：`恒为`

    例如：`令白马恒为“千里马”`，那么变量「白马」的值就只能是`“千里马”`，如果将这个变量给予新值，那它就会报`运行错误[34]：此变量的值不允许更改`！

3. 创建新的对象：`成为`

    例如：`令小明成为（考生：“李小明”）`。这个语句意思是创建一个新的「考生」对象，并将这个对象给到变量「小明」。

## 条件判断语句



根据使用情况的不同，条件判断语句分为三种不同结构，具体说明如下：

**基本的「如果」语句**

此种情况下只用「如果」语句；当且仅当输入条件为 `真` 时执行代码，其他情况下不执行程序。其语法结构为：

```zn
如果 ‹判断条件› ：
    ‹执行逻辑›
    ...
```

举个例子：

```zn
令我非常看重钱 = 真

如果我非常看重钱：
    注：以下部分即是要执行的内容
    输出「去香港卖保险吧！」
```

第3行的「我非常看重钱」即是判断条件，它是一个完整的表达式；因为它的值为真，所以后面第5行的「输出」语句会被执行；否则当「我非常看重钱」为假时，第4，5行的内容将不再执行。

**「如果」-「否则」组合**

在上面的基础之上，我们可以更进一步：当判断条件为 `真` 时，执行一部分逻辑，当判断条件为 `假` 时，执行另外一部分逻辑。其语法如下：

```zn
如果 ‹判断条件› ：
    ‹执行真逻辑›
    ...
否则：
    ‹执行假逻辑›
    ...
```

优化下上面的例子：

```zn
令我非常看重钱 = 真

如果我非常看重钱：    
    输出「去香港卖保险吧！」
否则：
    输出「可以考虑去学术界！」
```

整个代码要么输出「去香港卖保险吧！」，要么输出「可以考虑去学术界！」；

**「如果」-「再如」-「否则」组合**

再进一步，当我们需要用到多个分支时，我们可以加入「再如」语句去扩展多个分支的判断逻辑，其语法如下：

```zn
如果 ‹判断条件› ：
    ‹执行真逻辑›
    ...
再如 ‹判断条件2›：
    ‹执行再如逻辑›
    ...
再如 ‹判断条件3›：
    ‹执行再如逻辑›
    ...
否则：
    ‹执行假逻辑›
    ...
```

「再如」语句可以有多条，但是它一定是在「如果」语句和「否则」语句之间，否则会报错。这里举个实际例子：

```zn
令风力等级 = 12

如果风力等级 >= 6：
    如果风力等级 <= 7：
        输出“热带低压”
    再如风力等级 <= 9：
        输出“热带风暴”
    再如风力等级 <= 11：
        输出“强热带风暴”
    再如风力等级 <= 13：
        输出“台风”
    再如风力等级 <= 15：
        输出“强台风”
    否则：
        输出“超强台风”
否则：
    抛出异常：“还不够级别”！
```

## 循环执行语句

我们可以使用循环执行语句让程序重复执行某一段逻辑。循环执行语句分两种：「每当」语句和「遍历」语句，现具陈如下：

**「每当」语句**

「每当」语句以「每当」关键词开头，后面跟着一个判断条件，当这个判断条件的值为 `真` 时，后面的执行逻辑将会执行一遍又一遍，直到判断条件为 `假` 时，整条语句才会停止执行。其语法结构如下：

```zn
每当 ‹判断条件› ：
    ‹执行逻辑›
    ...
```

以下语句即通过反复执行加法操作来计算 `1 + 2 + 3 + ... + 100` 的值：

```zn
令总和 = 0
令N = 1

每当N <= 100：
    总和 = N + 总和
    N = N + 1

输出总和
```

> 注意：使用「每当」语句的判断条件时一定要非常小心；如果判断条件永远是 `真` 的话，此语句会一直执行，永不停歇 —— 亦即所谓「死循环」。以下即是一个「死循环」的典型例子：
>
> ```zn
> 每当真：
>     N = N + 1
> ```

**「遍历」语句**

「遍历」语句的功能是从头到尾遍历一个列表/字典，并取出每一项的值用于后续操作。「遍历」语句有三种语法格式：

1. 仅仅遍历某个列表/字典：

```
遍历 ‹列表/字典›：
    ‹执行逻辑› 
```

这种语法只是根据列表/字典元素的数量循环调用N次执行逻辑，比如说 `遍历【2、4、6、8、10】` 即是从列表的第一项一直循环到列表的最后一项，共运行5次。

2. 每次遍历时，仅取出此项的值

```
以 ‹值› 遍历 ‹列表/字典›：
    ‹执行逻辑› 
```

在从头到尾遍历列表/字典时，会将每个元素的值依次拎出来赋给「以」后面的变量。

```zn
以数据遍历【2、4、6、8、10】：
    （显示：数据）
```

就会依次显示 `2，4，6，8，10`.


3. 每次遍历时，取出此项的索引以及值

```
以 ‹索引›、‹值› 遍历 ‹列表/字典›：
    ‹执行逻辑› 
```

**「结束循环」及「继续循环」**


## 定义方法语句

（如何、已知、输出）

## 定义对象语句

（定义、其、何为）

## 导入模块语句

（导入）

## 异常处理语句

（抛出）

### 表达式：方法调用
##### 输出表达式的结果
表达式可以作为语句的一部分，同时也可以单独作为语句存在。举个例子：

```zinc
如果身高 >= 170，且体重 <= 70： // 
    输出“符合标准”
“不符合标准”   
```

第 1 行中 `身高 >= 170，且体重 <= 70` 即是一个表达式，它是 `如果` 语句的一部分；第 3 行中 `“不符合标准”` 也是一个表达式，它是单独作为语句存在的。

当程序执行的最后一条语句是表达式时，编译器会将这个表达式的值当成结果输出。在上面例子中，如果 `身高` 小于 `170` 或者 `体重` 大于 `70` ，程序会最终输出 `“不符合标准”`。 

##### 方法调用
方法调用即是通过传入指定的参数和方法名称，执行方法内预先编写的逻辑，并输出相应的结果值。方法调用的形式非常灵活多样，如下所示：

**1. 直接调用方法**

直接调用方法的语法格式如下：

```
‹方法表达式'›   ::=  （  ‹方法名›  ）
                |  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

> 和其他编程语言不同，这里的括号会把方法名以及对应参数全部包进去；这种设计主要出于分词考虑：如果像其他一样做成 `方法名（参数...）` 的话，一来格式上会产生疏离；二来方法名会和前面的对象产生混淆，造成无法分词的现象。

举个例子，假设我们事先设计了一个名为「求积」的方法，这个方法接受两个数值，并得到两者的乘积（亦即表达式的结果值为两者乘积）；现在要求 `4` 和 `9` 的乘积，就可以用 `（求积：4、9）` 来完成任务；

如果在调用某个方法时不需要传入参数，那么连冒号都可以不用了，直接在括号里写上方法名即可，如 `（结束）`。

**2. 调用元素对应的方法**

在 Zn 程序中，所有的变量值都属于 `元素` 类型，继而每一个元素都自带其对应的方法；这里的方法与面向对象语言中，对象的「方法」有异曲同工之妙。其语法格式如下：

```
‹方法表达式'›   ::=  以  ‹表达式›  （  ‹方法名›  ）
                |  以  ‹表达式›  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

比如说我们要求「价格」变量向上取整之后的值，就可以这么写：`以价格（向上取整）`。

**3. 得到结果的两种形式**

在调用完方法后，下一步即是获取对应的结果。获取结果的第一种形式即是通过赋值语句将结果传给某个变量，比如 `结果 = （求积：4、9）`；第二种形式即是使用 `得到` 关键字，将结果传给 `得到` 后面的变量，其语法如下所示：

```
‹方法表达式›   ::=  ‹方法表达式'›  得到  'ID
```

这种语法设计的好处即是让语句更加通顺，更加符合中文自身的语法，试举数例：

```
以价格（向上取整），得到显示价格
（求积：4、9），得到结果
```

> 注1：这里的逗号 `，` 是可选项，可以加上也可以省略。  
> 注2：`得到` 关键词后的变量将会自动进行声明，再进行传值。

**4. 方法的链式调用**

在调用变量对应的方法时，我们注意到 `以` 关键词后面也是个表达式；所以从理论上讲 `以以以以X（方法1）（方法2）（方法3）（方法4）` 这样诡异的表达式也是成立的。这个语句的具体执行逻辑是这样的：

- 先执行 `以X（方法1）`，其结果假设为 `X1`
- 将X1作为变量执行 `以X1（方法2）`，得到 `X2`
- 将X2作为变量执行 `以X2（方法3）`，得到 `X3`
- 将X3作为变量执行 `以X3（方法4）`，得到最终结果 `X4`

可以看到，这里看似俄罗斯套娃的语法实际上就是链式调用，上一个方法得到的值作为变量套到下一个方法中，最终得到结果。

为了避免上述诡异的语法产生，同时方便阅读，此处特地设计了一个链式调用的语法：

```
‹链式调用方法›   ::=  以  ‹表达式›  （  ‹方法名›  ：  ‹参数›  ） [、  （  ‹方法名›  ：  ‹参数›  ）]
```

因此，上面的语法即可改写成以下形式：

```
以X（方法1）、（方法2）、（方法3）、（方法4），得到X4
```