# zinc-server 使用指南

`zinc-server` 是和 `zinc` 配套的服务端程序，它可以接收客户端发起的HTTP请求，执行对应的 `zinc` 程序，并返回对应的结果。我们可以借助 `zinc-server` 开发后端接口，就像 PHP 一样编写 Web 应用。

`zinc-server` 采用 FastCGI 协议，亦即当客户端向服务端发起一个 HTTP 请求时，我们需要在前面用 nginx 之类的反向代理将其转换成 FastCGI 协议，再把请求转发到 `zinc-server` 处理；每接收到一个请求即创建/分配一个子进程，这个子进程将全权处理上面的请求；处理完成再将结果以HTTP响应的形式返回到客户端。

`zinc-server` 本身有自我保护机制：当某个请求处理时间过长时，对应的子进程将会被直接结束掉，防止计算资源被耗尽。

> 注意：`zinc-server` 目前只支持 POSIX 系统，如 Linux, MacOS 等；Windows **暂不支持** ！

## 启动服务器

在终端执行以下命令：

```bash
./zinc-server -l tcp://127.0.0.1:3862
```

即可启动服务器，并监听 `127.0.0.1` 地址下的 `3862` 端口。

默认情况下，`zinc-server` 进程是在前台启动的，如需将其放到后台启动，在命令后面加上一个 `&` 即可。

此命令支持的参数如下：

  - `-l (--listen)` ：指定服务器监听的URL，目前支持网络TCP 和 Unix Domain Socket 两种通信模式。如果采用 TCP 模式，URL 格式为 `tcp://[IP地址]:[端口号]`；如果采用 Unix Domain Socket 模式，其 URL 格式为 `unix://[socket 文件路径]`。 **其默认值为 `tcp://127.0.0.1:3862`**

  - `--timeout`：每次请求能够执行的最长时间，以秒为单位；当某次请求对应的执行时间超过时，其对应的进程将会自动退出，并返回 `502 Bad Gateway`。**其默认值为 `60`**

  - `--init-procs`：初始创建子进程的数量。当有请求进来时，服务端会自动将请求分配到某个子进程中，一个子进程同时只负责处理一个请求；因此当初始创建20个子进程时，服务器可以并发处理20个请求。子进程的数量并不是一成不变的，当发现现有子进程数量低于这个值时，服务端会自动创建新的子进程；而当所有的子进程都处于「忙碌」状态时，服务端会自动开启新的子进程用以承接更多的请求（只要上限不超过 `--max-procs` 指定的数量）。**其默认值为 `20`**

  - `--max-procs`：服务端允许创建的最大子进程数量。为防止服务端无限创建子进程，此处设置了创建子进程的上限，也就是无论什么情况下，服务端现存的子进程数量都不会超过这个数。**其默认值为 `100`**

## 配置处理模式

`zinc-server` 支持两种处理模式：`playground` 模式和 `http_handler` 模式。根据所传的 `ZINC_ADAPTER` FastCGI 参数不同，`zinc-server` 在每一次接收请求时会自动切换到对应的模式进行处理。

1. playground 模式
    
    如何启用：设置 `ZINC_ADAPTER = playground`

    playground 模式用于从请求内容中读取待执行的程序，执行并将结果以文本形式作为HTTP响应内容。这个模式因其直接执行输入的程序，常用于「在线运行程序」页面中（也就是所谓的「playground」了）

    在配置好相应的模式后，只要发送一个POST请求，并在请求的 body 中填写要执行的程序内空，即可得到结果，如下面的 curl 命令所示：

    ```sh
    curl -v --request POST \
        --url http://localhost:9090/ \
        --header 'Content-Type: text/plain' \
        --data "输出「千里之行，始于足下」"
    ```

    发送请求后，得到的响应为

    ```
    HTTP/1.1 200 OK
    Server: nginx/1.21.1
    Content-Type: text/plain; charset="utf-8"
    Transfer-Encoding: chunked
    Connection: keep-alive
    Date: Sun, 06 Aug 2023 15:03:06 GMT

    「千里之行，始于足下」
    ```

2. http_handler 模式

    如何启用：设置 `ZINC_ADAPTER = http_handler`

    http_handler 模式和正常的 HTTP 服务器别无二致，都是接收 HTTP 请求（GET/POST/PUT etc.），将请求参数放到指定的程序文件里面执行，最后输出结果。_这个流程实际上就是 `php-fpm` 目前所采用的处理 Web 请求的方式。_

    
> 注意：如果 `ZINC_ADAPTER` 参数不是上述两个值或者根本就没给，直接返回 403。

### nginx 配置

**使用 playground 模式**

在 nginx 下面新建一个 conf 文件，内容如下：

```
server {
    listen 9090;  // nginx 监听端口
    server_name localhost;

    location / {
        include fastcgi_params;

        fastcgi_pass 127.0.0.1:3862;   // 填入zinc-server 监听的地址     
        fastcgi_read_timeout 60s;
        fastcgi_param ZINC_ADAPTER playground;
    }
}
```

## 注意事项

1. 每个请求处理时间有限（预设是60秒），到时间了会强行中止请求并返回502。

## 番外篇：从「编译器」到「服务器」

最初在2020年开发 zinc 时，我的计划是把它打造成一门「使用中文的**编程语言**」-- 它对标的是诸如 Python, JS 之类的解释器：即是一个本地运行的可执行文件。因此，Zn 传统的执行流程如下： 

  1. 读取「指定程序文件」的源代码并将其转换为 zinc 内部的数据结构。
  2. 执行该程序的主循环，并逐行解释和执行程序代码。在执行过程中，zinc 会根据程序逻辑执行不同的操作，包括变量赋值、函数调用、条件语句判断等。
  3. 最后，当程序执行完毕或者出现错误时，zinc 会输出相应的结果或者错误信息，并终止程序的运行。

在这个流程下，解释器的输入是**程序源代码**，输出没有作出要求；解释器只负责执行，源代码要输出什么就输出什么 -- 导出文件、修改数据库、打印信息到 stdout 上...同时解释器在执行程序时，会把各路依赖都加载一遍，这就使得执行一次程序会相对「重」一些，这就使得传统的解释器倾向于独立完成所有任务（比如开发一个Web服务，选定一个编程语言就会「一条路走到黑」）；而对于集成进其他服务中并不友好。

所以，我们可以采用一种新的方式：将程序语言的处理服务化 -- 在后台开启一个服务器进程，接收输入数据和程序，处理请求，并输出结果。采用这种方式的好处有两点：

  1. 方便和其他语言集成 - 从其他编程语言的视角来看，这就是个RPC调用
  2. 方便并行处理多个执行请求 - 这个有点类似 PHP-FPM 的工作模式

但是，这种模式最大的缺点就是需要常驻进程在机器上，对于单机应用/单次执行的场景并不友好；这就使得目前「编译器」和「服务器」两种模式都做，分别对应了 `zinc` 和 `zinc-server`。

`zinc-server` 的具体处理请求流程如下：

1. 后台启动 `zinc-server` 主进程，监听某个端口并预先创建数个子进程
2. 当客户端发起请求时，其中一个子进程接收请求，读取并处理数据
    - 程序代码要求是「短链」的，亦即在规定时间内处理完，而不能是常驻的死循环
    - 当处理时间超过一定值（如60s）时，子进程将会自动 kill 掉以防止过度占用机器资源

3. 将输出的值序列化返回到客户端中


### 2024/3/22 NOTE

1. `zinc-server` 和 `zinc-playground` 在设计上最大的不同在于：前者的处理代码是预先编写好的，是可控的 -- 因此不用担心执行代码把服务器搞挂掉，从而可以使用 `1个请求开1个 goroutine` 的模式提升 I/O 处理性能；

2. 但是 `zinc-playground` 要执行的代码都是用户提交的，是不可控的（天知道用户写个死循环/恶意占用内存等骚操作把服务器搞崩掉）；所以我们需要对每一次执行兜底 - 如果执行时间过长/占用资源过多，服务器应直接把进程干掉。因此我们采用 `1个请求开1个进程` 的模式，虽然这种类似于 PHP-FPM 的模式性能不是很好，但是至少出了事情我们可以直接把进程干掉！

3. zinc-server 需要指定一个文件作为执行入口，这个文件所在的目录即是模块的根目录；这个文件一开始需要用 `输入HTTP请求` 把 `HTTP请求` 作为变量导进去 - 然后再输出一个值（根据值的类型不同，输出不同的 content-type: 如果是 `字典` 类型，content-type = json）


### 2024/3/23 NOTE

1. `输入` 语句一引入，就决定了 zinc 是一个次级编程语言 - 因为执行这段代码需要主环境给定参数

2. zinc [file] --var-input xxx.zn (xxx.zn 是一个专个用于定义输入参数的文件，举例)

```zn
长 = 20
宽 = 100
高 = 50
A/B测试 = 真
```

3. 实际上输入参数应该在 context 里就应该准备好，到时走 evalProgram() 时可以直接拿来用

4. REPL 不支持输入语句（语法没问题，但是执行时要报错：因为这根本没法搞嘛！）

5. Playground 在传代码的同时也要把 输入变量传进去，所以我估计 HTTP 输入参数得这么设计：

```js
POST /run

{
  "varInput": [
    "长 = 20",
    "宽 = 100",
    "高 = 50",
    "A/B测试 = 真"
  ],
  "sourceCode": "输入长、宽、高\n输出长 + 宽 + 高"
}
```

6. HTTP handler 在执行代码时，context 里预设的输入应该是 HTTP请求 - 将当前请求封装成一个对象（如 方法 = POST，URL = /run，参数 = 【=】...） 一个适用于 HTTP handler 处理的代码格式：

```zn
输入HTTP请求

如果HTTP请求之URL == 「/run」：
    输出「千里之行，始于足下」 --> text/plain
再如HTTP请求之URL == 「/version」：
    输出【
        版本 = 「rev8」
        日期 = 「2024/3/1」
    】  --> application/json

// 否则就输出空 --> text/plain 里面没有文本
```

7. 在同一个 context 下面可以输入多次：比如主模块 `输入A、B、C` 在导入其他模块时，如果其他模块也有 `输入` 语句，那么其他模块的输入语句也可以使用（虽然不建议多个模块都用`输入` 语句，不方便管理）