# 执行架构

## 设计的转变：从「编译器」到「服务器」

**最初的解释器方案**

最初，在2020年计划开发 Zn 时，我的想法是把它打造成一门「使用中文的**编程语言**」-- 它对标的是诸如 Python, JS 之类的解释器：即是一个本地运行的可执行文件。因此，Zn 传统的执行流程如下： 

1. 读取「指定程序文件」的源代码并将其转换为 Zn 内部的数据结构。
2. 执行该程序的主循环，并逐行解释和执行程序代码。在执行过程中，Zn 会根据程序逻辑执行不同的操作，包括变量赋值、函数调用、条件语句判断等。
3. 最后，当程序执行完毕或者出现错误时，Zn 会输出相应的结果或者错误信息，并终止程序的运行。

在这个流程下，解释器的输入是**程序源代码**，输出没有作出要求；解释器只负责执行，源代码要输出什么就输出什么 -- 导出文件、修改数据库、打印信息到 stdout 上... whatever you want；同时解释器在执行程序时，会把各路依赖都加载一遍，这就使得执行一次程序会相对「重」一些，这就使得传统的解释器倾向于独立完成所有任务（比如开发一个Web服务，选定一个编程语言就会「一条路走到黑」）；而对于集成进其他服务中并不友好。

所以，我们可以采用一种新的方式：将程序语言的处理服务化 -- 在后台开启一个服务器进程，接收输入数据和程序，处理请求，并输出结果。

**TBD**


**服务处理流程**

1. 后台启动进程

2. 发起一个新的请求，将程序代码和输入数据
    - 程序代码要求是「短链」的，亦即在规定时间内处理完，而不是 while True 死循环（有点像现在 serverless 提倡的 lambda function）

3. 处理请求，将输出的值序列化返回来

4. 外部程序接收输出的值，将输出值翻译成自己看得懂的部分 （比如说 string 之类的，随意啦...）