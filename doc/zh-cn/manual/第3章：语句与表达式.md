# 第3章：语句与表达式

### 语句与语句块
**语句** (statement) 是一条完整的指令，它可以指挥电脑去执行一项具体的操作；将这些语句一条条叠加起来，即是一个完整的程序。一条完整的语句由多个词汇（关键词/标识符/文本）组合而成，且需要遵循一定的语法才能正确执行：比如 `令年龄 = 20` 即是一条正确的语句，它是由 `令`，`年龄`，`=`，`20` 这四个词拼在一起的；而 `令年龄为空` 则不然，`令`  后面不能有 `为` 关键词！

语句之间可以叠加在一起，特定语句甚至可以嵌套子语句。当数条语句叠加在一起时，我们即称这一个整体为**语句块** (statement block)。同一个语句块内的缩进值（简单来说就是每行前面的空格数）应保持一致，举个例子：

```zn
如果地区为“华南”：
    年龄 = 20
    姓名 = “小明”
    身高 = 175
否则：
    年龄 = 15
    姓名 = “小方”
    身高 = 160
```

在上面的程序中，第1-8行是一条完整的 `如果` 语句，它嵌套了两个单独的语句块：第2-4行，以及第6-8行。

##### 语句之间的分隔
语句与语句之间需要用特定的字符分隔开，否则编译器无法正确识别语句内容。比如 `令年龄 = 20` 是一条完整的语句， `令姓名 = “小明”` 也是一条完整的语句；但是将两个语句直接连起来，变成`令年龄 = 20令姓名 = “小明”` 即是不正确的，会抛出语法错误。

通常情况下，我们会通过换行的方式（按下 Enter 键）来写一条新的语句；从程序的角度，这实际上是在一行的末尾添加了一个「换行符」¹ ，每一条语句之间都使用「换行符」分隔开，比如下面两条语句即是通过换行的方式分隔；

```zn
令年龄 = 20
令姓名 = “小明”
```

还有一种情况，如果需要将多条语句放在同一行，我们即可以使用 _分号_ `；` 来分隔语句。同一行可以使用多个 _分号_ `；`  如下所示：

```zn
令年龄 = 20；令姓名 = “小明”；令身高 = 160
```

##### 词素之间的分隔
一条语句是由关键词/标识符/标点/运算符等各个词素 (token) 组成的，如 `令年龄 = 20` 即是由 *关键词* `令` + *标识符* `年龄`  + *运算符* `=` + *标识符* `20` 组合而成。

和其他语言不同， zinc 语言采用 _无空格设计_，也就是说各个词素之间（尤其关键词及标识符）不用加空格也能够正常解析。这就意味着，词素之间可以不用加任何字符加以区分！

不过，我们在编写语句的过程中可以在词素之间适当地加上 *空格* ` ` 或者*逗号* `，` 以方便阅读；*空格* 或 *逗号* 仅仅起到标记分隔的作用，并不会成为语句的一部分（就像真·逗号在文章中用于句子的停顿）。我们不妨参考以下几条案例：

**案例甲**： `如果年龄小于30且身高大于160且专业相关为真：` 是一条合法的 `如果` 语句，但直接读起来实在让人一头雾水；于是我们可以在语句之间适当加上逗号，这样阅读起来就更有条理：`如果 年龄小于30，且身高大于160，且专业相关为真：`
**案例乙**： `【10 20 30 40 50】` 用于表示一个列表以及其内含的五个数值。每项之间需要加上空格或者逗号以分隔，故而 `【10，20，30，40，50】`也是可行的。
**案例丙**：在赋值语句中，等号两边加上空格会更有助于阅读，如`年龄差 = 20` 会比 `年龄差=20` 效果更好。

### 表达式
**表达式** (expression) 是由数值/变量/方法等元素与运算符组合而成的式子，并且这个式子经过特定运算后会得到最终的元素值。

表达式可分为两种类型：**基础表达式** (primitive expression) 以及**复合表达式** (compound expression)；基础表达式是表达式的基本单元，包括变量名、数值等单独元素，如 *数值* `250` 或者*文本* `“黄河之水天上来”`。基础表达式可以分成以下几种类型：

1. **变量名称：**当一个标识符被当作变量名使用时，这个标识符本身即是一个表达式，其结果为此变量对应的元素值。如语句 `令价格 = 20；令客单价 = 价格` 中，第二条语句等号右边的 `价格` 即是一个单独的变量名，此即一个表达式，结果为 `20`。
2. **数值：**如语句 `令价格 = 20.46` 中，等号右边的 `20.46` 即是一个数值，它代表了数值 `20.46` ！
3. **文本：**与数值类似，自身即元素；如语句 `令诗句 = “黄河之水天上来”`中，等号右边的 `“黄河之水天上来”`即是一个文本表达式，其结果为一个包含了 `黄河之水天上来` 这7个字符的文本元素。
4. **列表：**我们可以通过在 `【 】` 内部列举所有元素的方式来直接表示一个列表元素；如 `令等差数列 = 【1，3，5，7，9】` 中，等号右边的 `【1，3，5，7，9】` 即是一个包含了5个元素的列表。
5. **字典：**与列表类似，我们可以通过在 `【 】` 内部列举所有键值对的方式来直接表示一个字典元素（注意键值对中间一定要有 `=`，否则会与列表元素产生混淆）；如 `令五笔简码字典 = 【H = “上”，J = “是”，K = “中”，L = “国”，M = “同”】`中，等号右边的部分即是一个完整的字典元素。

复合表达式即是在基础表达式的基础上，通过运算符等方式组合而成。如 `25的平方 + 4 * 3` 即是一个复合表达式，其对应结果为 `637`。

1. **算术运算符**

算术运算符包括我们平时熟知的加、减、乘、除；它夹在两个表达式中间，在执行时按照一定的优先级进行计算，得到最终结果。其对应的语法为：`‹表达式1› ‹运算符› ‹表达式2›`；比如 `4 + 3` 即是将左边的 `4` 和 右边的 `3` 通过中间的 `+` 进行运算，最后得到数值 `7`。

**四则运算：加、减、乘、除**

如果左右两个表达式的类型都是数值，那么两者之间可以进行加、减、乘、除等四则运算，就像我们在小学时期学过的数学表达式一样。各个运算所使用的运算符如下所示：

| 运算方法 | 表达式 | 示例           |
|------|-----|--------------|
| 加法   | `+` | `成本 + 5`     |
| 减法   | `-` | `利润 - 3.7`   |
| 乘法   | `*` | `销售额 * 0.25` |
| 除法   | `/` | `回款 / 5`     |
| 取余   |     |              |
|      |     |              |

> ⚠️ 尽管 zinc 秉承着「非必要不加空格」原则，但是在输入运算表达式时，运算符前后**必须要加上空格**；这是因为 `+ - * /` 本身是可以作为标识符的一部分的，如果不加空格，诸如 `价格/2` 本身是会当作标识符本身而出现不符合预期的结果的！

四则运算符是可以连起来一直执行的，比如 `1 + 2 + 3 + 4 + 5 + 6 - 7` 是可以正常执行的（结果是`14`）；同时四则运算遵循「先乘除，后加减」的原则，优先执行乘除运算，再执行加减运算，比如 `3 + 5 * 7` 就是先执行 `5 * 7` 的表达式，得到 `35` 的结果后再和 `3` 相加，最后得到 `38`。

**逻辑运算：「且」**

「且」运算符用于同时比较两个条件是否都为真，如果两个条件都为真，则整个条件表达式的结果也为真。举个例子，如果我们要判断一个人是否符合做网约车司机，我们即可以使用「且」运算符连接两个条件：

```zn
年龄 > 18且会开车
```

其中「年龄 > 18」表示这个人的年龄大于18岁，变量「会开车」表示这个人是否会开车，如果「年龄 > 18」的值为`真`，而「会开车」的值也为`真`，则整个条件表达式的结果为`真`。

「且」运算符的真值表如下所示：

| 表达式1 | 表达式2 | 结果 |
|------|-------|-------|
| `真` |  `真`  | `真` |
| `真` |  `假`  | `假` |
| `假` |  `真`  | `假` |
| `假` |  `假`  | `假` |

**逻辑运算：「或」**

除了「且」运算符外，「或」用于比较两个条件中是否至少有一个为真；如果**至少有一个**条件为真，则整个条件表达式的结果也为真。举个例子，假设某学校的录取条件是英语成绩达标（雅思、托福均可），我们即可使用「或」运算符连接两个条件：

```zn
雅思 >= 6.5或托福 > 105
```

只要「雅思 > 6.5」表达式为`真`，或者「托福 > 105」表达式为`真`，整个条件表达式的结果为`真`。

「或」运算符的真值表如下所示：

| 表达式1 | 表达式2 | 结果 |
|------|-------|-------|
| `真` |  `真`  | `真` |
| `真` |  `假`  | `真` |
| `假` |  `真`  | `真` |
| `假` |  `假`  | `假` |

> 和其他关键字一样，`且` 和 `或` 关键字前后都不用加空格区分。

**比较运算符**

比较运算符是用来比较两个值之间的关系的。通常来说，比较运算符会返回一个逻辑值，即 `真` 或 `假`。

目前系统支持共 6 种比较运算符，如下所示：

| 运算符  | 功能 |
|-----|-----|
| `==` （`等于`）| 检查A是否等于B |
| `/=` （`不等于`）| 检查A是否不等于B |
| `>` （`大于`）| 检查A是否大于B |
| `<` （`小于`）| 检查A是否小于B |
| `>=` （`不小于`）| 检查A是否大于或者等于B |
| `<=` （`不大于`）| 检查A是否小于或者等于B |

括号内的中文是对应运算符的关键字，两者完全等价。也就是说，`A == B` 和 `A等于B` 是一个意思。

目前，我们只支持**数值**类型的比较，诸如**文本**、**列表**类型的比较请使用其他方法。

比较运算符的使用方法很简单，只需要把要比较的值放在运算符两侧即可。比较运算符的结果是一个逻辑值，可以用于各种逻辑判断。

**用花括号组合**

在某些情况下，我们希望程序能够优先执行某一部分组合，即使正常情况下它们还没到这个优先级；这个时候我们即可以在需要优先执行的表达式和运算符之间加上一对花括号 `{` `}`；其 BNF 语法如下所示：

```zn
‹基础表达式›   ::=  {  ‹表达式›  }
```

举个简单的例子：我们都知道四则运算遵循「先乘除，后加减」的原则，因此表达式 ` 2 + 3 * 5` 的结果应是数值 `17`。而如果加上花括号，则表达式 `{2 + 3} * 5` 中优先执行花括号内的组合，得到 `5`，再进行乘法，得到结果 `25`。

2. **获取元素的属性**

所有的变量都是对象，都有其对应的属性；我们可以通过对应的表达式获取变量的某个属性；获取属性的语法如下所示：

```
‹属性表达式›   ::=  ‹表达式›  [之  |  的]  'ID
```

`之` 或 `的` 从语法上没有任何区别，在实际使用时可以凭借表达式以及属性的名称的通顺程度来决定使用哪个关键字。

同时，在部分确定上下文的情况下（比如说在 `定义` 语句下），我们可以用 `其` 关键字来指代指定的元素，其语法如下所示：

```
‹属性表达式›   ::=  其  'ID
```


3. **获取列表/字典的成员**

对于列表/字典类型的变量而言，我们能够通过对应的索引获取到这个变量对应的某个值；
- 如果是列表类型，可以通过索引获取其第 N 个元素的值 （**N从1开始**）
- 如果是字典类型，可以通过索引获取某个键名下的值

其语法大致如下所示：

```
‹成员表达式›   ::=  ‹表达式›  #  '数值
               |  ‹表达式›  #  '文本
               |  ‹表达式›  #  {  ‹表达式›  }
```

试举数例：

```zn
【2、4、6、8、10】#2     注1：获取列表的第2个元素，结果为4
【T=“和”，R=“的”，E=“有”】#E   注2：获取字典中“E”对应的值，结果为“有”
【2、4、6、8、10】#{5 - 3}     注3：获取列表的第2个元素，结果为4
```


4. **调用方法**

方法调用即是通过传入指定的参数和方法名称，执行方法内预先编写的逻辑，并输出相应的结果值。方法调用的形式非常灵活多样，如下所示：

**1. 直接调用方法**

直接调用方法的语法格式如下：

```
‹方法表达式'›   ::=  （  ‹方法名›  ）
                |  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

> 和其他编程语言不同，这里的括号会把方法名以及对应参数全部包进去；这种设计主要出于分词考虑：如果像其他一样做成 `方法名（参数...）` 的话，一来格式上会产生疏离；二来方法名会和前面的对象产生混淆，造成无法分词的现象。

举个例子，假设我们事先设计了一个名为「求积」的方法，这个方法接受两个数值，并得到两者的乘积（亦即表达式的结果值为两者乘积）；现在要求 `4` 和 `9` 的乘积，就可以用 `（求积：4、9）` 来完成任务；

如果在调用某个方法时不需要传入参数，那么连冒号都可以不用了，直接在括号里写上方法名即可，如 `（结束）`。

**2. 调用元素对应的方法**

在 Zn 程序中，所有的变量值都属于 `元素` 类型，继而每一个元素都自带其对应的方法；这里的方法与面向对象语言中，对象的「方法」有异曲同工之妙。其语法格式如下：

```
‹方法表达式'›   ::=  以  ‹表达式›  （  ‹方法名›  ）
                |  以  ‹表达式›  （  ‹方法名›  ：  ‹表达式›  [、  ‹表达式›]+  ）
```

比如说我们要求「价格」变量向上取整之后的值，就可以这么写：`以价格（向上取整）`。

**3. 得到结果的两种形式**

在调用完方法后，下一步即是获取对应的结果。获取结果的第一种形式即是通过赋值语句将结果传给某个变量，比如 `结果 = （求积：4、9）`；第二种形式即是使用 `得到` 关键字，将结果传给 `得到` 后面的变量，其语法如下所示：

```
‹方法表达式›   ::=  ‹方法表达式'›  得到  'ID
```

这种语法设计的好处即是让语句更加通顺，更加符合中文自身的语法，试举数例：

```zn
以价格（向上取整），得到显示价格
（求积：4、9），得到结果
```

> 注1：这里的逗号 `，` 是可选项，可以加上也可以省略。  
> 注2：`得到` 关键词后的变量将会自动进行声明，再进行传值。 

**4. 方法的链式调用**

在调用变量对应的方法时，我们注意到 `以` 关键词后面也是个表达式；所以从理论上讲 `以以以以X（方法1）（方法2）（方法3）（方法4）` 这样诡异的表达式也是成立的。这个语句的具体执行逻辑是这样的：
- 先执行 `以X（方法1）`，其结果假设为 `X1`
- 将X1作为变量执行 `以X1（方法2）`，得到 `X2`
- 将X2作为变量执行 `以X2（方法3）`，得到 `X3`
- 将X3作为变量执行 `以X3（方法4）`，得到最终结果 `X4`

可以看到，这里看似俄罗斯套娃的语法实际上就是链式调用，上一个方法得到的值作为变量套到下一个方法中，最终得到结果。

为了避免上述诡异的语法产生，同时方便阅读，此处特地设计了一个链式调用的语法：

```
‹链式调用方法›   ::=  以  ‹表达式›  （  ‹方法名›  ：  ‹参数›  ） [、  （  ‹方法名›  ：  ‹参数›  ）]
```

因此，上面的语法即可改写成以下形式：

```zn
以X（方法1）、（方法2）、（方法3）、（方法4），得到X4
```

###### 输出表达式的结果
表达式可以作为语句的一部分，同时也可以单独作为语句存在。举个例子：

```zinc
如果身高 >= 170，且体重 <= 70： // 
    输出“符合标准”
“不符合标准”   
```

第 1 行中 `身高 >= 170，且体重 <= 70` 即是一个表达式，它是 `如果` 语句的一部分；第 3 行中 `“不符合标准”` 也是一个表达式，它是单独作为语句存在的。

当程序执行的最后一条语句是表达式时，编译器会将这个表达式的值当成结果输出。在上面例子中，如果 `身高` 小于 `170` 或者 `体重` 大于 `70` ，程序会最终输出 `“不符合标准”`。 


### 附录甲：可用语句列表
以下是 zinc 语言所支持的所有语句列表，以供读者参考。这些语句的具体用法会在后面的章节中详细解释。

| 语句类型 | 常用语法                                   | 示例                                                           |
|------|----------------------------------------|--------------------------------------------------------------|
| 令字语句 | `令 ‹变量名› = ‹初始值›`                      | `令价格 = 20.5`                                                 |
| 每当语句 | `每当‹表达式›：<br>    ‹语句块›`                | `每当I > 0：<br>    I = I - 1`                                  |
| 遍历语句 | `以‹变量名›遍历‹表达式›：<br>    ‹语句块›`          | `以参数遍历【1，2，3，4，5】：<br>    （显示：参数）`                           |
| 如果语句 | `如果‹表达式›：<br>    ‹语句块›`                | `如果I > 0：<br>    输出“正数”`                                     |
| 如何语句 | `如何‹方法名›？<br>    ‹语句块›`                | `如何求和？<br>    输入左、右<br>    令结果 = 左 + 右<br>    输出结果`          |
| 输入语句 | `输入‹变量名›、‹变量名›…`                       | `输入品名、SKU、单价`                                                |
| 输出语句 | `输出‹表达式›`                              | `输出“正确文本”`                                                   |
| 导入语句 | `导入“‹模块名›”`                            | 导入“模块甲”                                                      |
| 抛出语句 | `抛出‹异常类型›：‹表达式›！`                      | `抛出调用异常：“异常信息”！`                                             |
| 拦截语句 | `拦截‹异常类型›：<br>    ‹语句块›`               | `拦截调用异常：<br>    （显示：“接收异常：”、其内容）`                            |
| 定义语句 | `定义‹类型名›：<br>    ‹属性列表›<br>    ‹方法列表›` | `定义货件：<br>    其尺寸 = 【20，30，40】<br>    如何计算围长？<br>        输出2 * {其尺寸#1 + 其尺寸#2}`     |

### 附录乙：运算符的优先级

**运算符的优先级**

运算符的优先级决定了表达式中运算执行的先后顺序。当一个表达式中包含了多个运算符时，我们先按照优先级高低依次执行，高优先级的表达式的执行结果即作为低优先级表达式的操作数；相同优先级的表达式即按照**从左往右**的顺序依次执行。

运算符的优先级列表如下所示，数字越大表示优先级越高：

<table>
  <thead>
    <tr>      
      <th align="center">优先级</th>
      <th>运算符类型</th>
      <th>运算符</th>      
      <th>备注</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td align="center">八级</td>
      <td>花括号组合</td>
      <td><code>{ }</code></td>
      <td><i>使用方法见下一节</i></td>
    </tr>
    <tr>
      <td align="center">七级</td>
      <td>访问列表元素</td>
      <td><code>#</code></td>
      <td><code>【10、20】#1 + 1</code> 得到 11 而不是 20</td>
    </tr>
    <tr>
      <td align="center" rowspan="2">六级</td>
      <td>乘法</td>
      <td><code>*</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>除法</td>
      <td><code>/</code></td>
      <td>乘除是并列的</td>
    </tr>
    <tr>
      <td align="center" rowspan="2">五级</td>
      <td>加法</td>
      <td><code>+</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>减法</td>
      <td><code>-</code></td>
      <td>加减是并列的</td>
    </tr>
    <tr>
      <td align="center">四级</td>
      <td>赋值</td>
      <td><code>为</code>，<code>=</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center" rowspan="6">三级</td>
      <td>相等（数值比较）</td>
      <td><code>等于</code>，<code>==</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>不相等（数值比较）</td>
      <td><code>不等于</code>，<code>/=</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>大于（数值比较）</td>
      <td><code>大于</code>，<code>&gt;</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>小于（数值比较）</td>
      <td><code>小于</code>，<code>&lt;</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>大于等于（数值比较）</td>
      <td><code>不小于</code>，<code>&gt;=</code></td>
      <td></td>
    </tr>
    <tr>      
      <td>小于等于（数值比较）</td>
      <td><code>不大于</code>，<code>&lt;=</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center">二级</td>
      <td>逻辑与</td>
      <td><code>且</code></td>
      <td></td>
    </tr>
    <tr>
      <td align="center">一级</td>
      <td>逻辑或</td>
      <td><code>或</code></td>
      <td></td>
    </tr>
  </tbody>
</table>