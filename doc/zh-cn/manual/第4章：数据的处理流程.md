# 第4章：数据的处理流程

我们编写程序的目的，是为了让计算机帮助我们解决问题；具体来说，程序通过接收输入数据并进行处理后，输出相应的结果，从而实现我们的目标。事实上，程序的执行过程就是一个数据处理的流程！

在 zinc 语言中，程序会在外部环境（依赖于平台）中预先定义一些变量及其值，然后通过 `输入` 语句将这些变量引入程序，最后将结果*输出*到外部环境，或者在出现异常时*中止程序*。为保证数据的处理流程的正确性，不同类型的语句需要满足一定的顺序，否则在程序执行之前即会报出语法错误！

### 数据的输入
如前所述，为了将外部数据输入到程序中，我们需要使用 `输入` 语句，在程序内部“重新”定义这些变量，且其初始值即是对应的外部数据值。

`输入` 语句的语法为 `输入‹变量甲›、‹变量乙›、‹变量丙›...` 。其中 `变量` 须为一个有效的标识符；如需引入多个变量名，变量之间需用*顿号* `、` 分隔。

举个例子，假设我们在外部环境已经准备好了以下变量的值：

| 名称   | 值           |
| ---- | ----------- |
| 货件名称 | `“置物架”`     |
| 采购数量 | `500`       |
| 采购单价 | `24.8`      |
| 供应商  | `“甲乙丙丁加工厂”` |
我们可以写一条简单的程序用于计算采购总价，其代码如下：
```zinc
输入采购数量、采购单价  // 此处属于「输入」段
令总价 = 采购数量 * 采购单价 // 此处属于「逻辑」段
输出总价 
```

在程序的第 1 行，语句  `输入采购数量、采购单价`  即从外部环境中”抓取“ `采购数量` 和 `采购单价` 这两个变量，并分别赋予数值 `500` 和`24.8`；而后，第 2 行就可以直接使用 `采购数量 * 采购单价` 来计算结果了。

值得注意的是，通过输入语句定义的变量值实际上是**常量**，亦即无法通过赋值语句二次修改！
###### 使用输入语句的好处
在上面的程序中，我们完全可以用「令字句」去定义变量，省略输入语句，将数值直接传进去：

```zinc
令采购数量 = 500；令采购单价 = 24.8  
令总价 = 采购数量 * 采购单价
输出总价 
```

那为什么还要特地设计一个 *输入语句* 呢？其原因有以下几点：
1) *程序可以复用：* 如果输入值发生变化，只要在外部环境中修改对应的变量值即可，不需要修改程序本身。
2) *结构结构更加清晰：* 如果直接使用 「令字句」的话，到时会将本属于外部定义的变量和内部定义的变量混淆。
3) *保证输入变量不会被意外修改：* 通过输入语句定义的变量值实际上是「常量」，无法通过赋值语句二次修改！

### 数据的输出
执行程序的最终目标自然是输出结果。在 zinc 语言中，输出结果有两种方式：
1. **使用 `输出` 语句**：`输出`语句的语法为： `‹输出语句› → 输出 ‹表达式› ` 。当程序执行到这条语句时，我们会将 `输出` 后面表达式的元素值输出到外部环境中来，并立即结束整个程序。如以下代码所示：
   ```zinc
	令采购数量 = 500；令采购单价 = 24.8  
	令总价 = 采购数量 * 采购单价
	输出总价
	// ...
	（后面的流程）  // 此处将不再执行
	```
	当程序从上到下执行到第 3 行时， `输出总价` 语句即会将 `总价` 这个表达式的值 （也就是*数值* `12400`）输出到外部环境中来，并且终止整个程序的运行 - 后面的第四，第五行自然也就执行不到了。 
   
2. **最后一行表达式**：
   表达式可以作为语句的一部分，同时也可以单独作为语句存在。在一般情况下，程序会在没有 `输出` 语句的前提下从第一行执行到最后一行；如果最后一行恰好是一个完整的表达式，那么我们会将这个表达式的元素值作为结果返回到外部环境中，如下面的例子所示：

	```zinc
	如果身高 >= 170，且体重 <= 70： // 
	    输出“符合标准”
	“不符合标准”   
	```

	第 1 行中 `身高 >= 170，且体重 <= 70` 即是一个表达式，它是 `如果` 语句的一部分；第 3 行中 `“不符合标准”` 也是一个表达式，它是单独作为语句存在的。

	当程序执行的最后一条语句是表达式时，编译器会将这个表达式的值当成结果输出。在上面例子中，如果 `身高` 小于 `170` 或者 `体重` 大于 `70` ，程序会最终输出 `“不符合标准”`。 

### 程序的语句分段
在一个程序中，不同类型语句的顺序是有要求的，比如 `导入` 语句必须要在程序的最开头，`拦截` 语句必须在程序的末尾；为了方便理解，我们将一个程序划分成四个语句段：**导入段**、**输入段**、**逻辑段**和**拦截段**；每个语句段都有其对应的语句类型，根据不同要求可以填入一条或多条，甚至不填也行；但是语句段之间的顺序不能对调，诸如「先写输入语句，再写导入语句」是会报语法错误的！

每个程序分段的作用及对应的语句要求如下：

##### 1. 导入段
导入段由 `导入` 语句组成，其作用为描述在这段程序中要预备导入的其他模块。导入段允许**多条**导入语句；导入语句由 `导入` 关键词开头，后面跟上需要导入的模块名称以及对应的方法/类型，如 `导入《JSON》之解析JSON`  等。

##### 2. 输入段
输入段由 `输入` 语句组成，它定义了一系列需要由外部环境提供的变量。输入段只允许**一条** `输入` 语句！

##### 3. 逻辑段
逻辑段即是实际用于执行的代码逻辑。里面可以写多条语句，除了 `输入`、`导入`、`拦截` 语句之外，其他语句都可以放到逻辑段中。事实上，程序在运行完逻辑段的语句之后，要么输出最终结果，要么抛出异常。若是前者，则输出结果后结束执行；若是后者，程序会转到 `拦截段`，尝试拦截异常并执行对应的逻辑，拦截无果后再显示异常并结束执行。

##### 4. 拦截段
拦截段用于「拦截」由逻辑段所产生的异常。作为程序的最后一个语句段，拦截段只允许 `拦截` 语句；拦截段支持**多条** 拦截语句，以匹配不同类型的异常。

以下是一个拥有完整四个语句段的程序实例：

```zinc
// 1. 导入段
导入《JSON》  
导入“模块二”

// 2. 输入段
输入起订量、数量、单价

// 3. 逻辑段
如果数量 < 起订量：
    抛出异常：“订单数量 {}件；不够起订量 {}件” % 【数量，起订量】
否则：
	输出数量 * 单价

// 4. 拦截段
拦截异常：
	（显示：其内容）
```

### 异常的抛出与拦截
 **TBD**