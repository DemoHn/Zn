package syntax

import (
	"github.com/DemoHn/Zn/error"
	"github.com/DemoHn/Zn/lex"
)

//////// Node types

// Node -
type Node interface{}

type consumerFunc func(idx int, nodes []Node) (Node, *error.Error)

// Statement -
type Statement interface {
	Node
	stmtNode()
}

// Expression - a speical type of statement - that yields value after execution
type Expression interface {
	Statement
	exprNode()
}

//// program (struct)

// Program -
type Program struct {
	Content *BlockStmt
}

// NodeList - a node that packs several nodes
type NodeList struct {
	Tag      int
	Children []Node
}

//// Statements (struct)

// VarDeclareStmt - declare variables as init its values
type VarDeclareStmt struct {
	AssignPair []VDAssignPair
}

// EmptyStmt - contains nothing - generated by a semicolon token
type EmptyStmt struct{}

// VDAssignPair - helper type
type VDAssignPair struct {
	Variables  []*ID
	AssignExpr Expression
}

// BranchStmt - conditional (if-else) statement
type BranchStmt struct {
	// if
	IfTrueExpr  Expression
	IfTrueBlock *BlockStmt
	// else
	IfFalseBlock *BlockStmt
	// else if
	OtherExprs  []Expression
	OtherBlocks []*BlockStmt
	// else-branch exists or not
	HasElse bool
}

// WhileLoopStmt - (while) statement
type WhileLoopStmt struct {
	// while this expression satisfies (return TRUE), the following block executes.
	TrueExpr Expression
	// execution block
	LoopBlock *BlockStmt
}

// BlockStmt -
type BlockStmt struct {
	Children []Statement
}

// implement statement inteface
func (vn *VarDeclareStmt) stmtNode() {}
func (bk *BlockStmt) stmtNode()      {}
func (bs *BranchStmt) stmtNode()     {}
func (es *EmptyStmt) stmtNode()      {}
func (wl *WhileLoopStmt) stmtNode()  {}

//// Expressions (struct)

// PrimeExpr - primitive expression
type PrimeExpr struct {
	Literal string
}

// ID - Identifier type
type ID struct {
	PrimeExpr
}

// Number -
type Number struct {
	PrimeExpr
}

// String -
type String struct {
	PrimeExpr
}

// unionMapList - HashMap or ArrayList, since they shares similar grammer.
// e.g.  ArrayList  => 【1，2，3，4，5】
//       HashMap    => 【A == 1，B == 2】
type unionMapList interface {
	Expression
	mapList()
}

// ArrayExpr - array expression
type ArrayExpr struct {
	Items []Expression
}

// HashMapExpr - hashMap expression
type HashMapExpr struct {
	KVPair []HashMapKeyValuePair
}

// HashMapKeyValuePair -
type HashMapKeyValuePair struct {
	Key   Expression
	Value Expression
}

// ArrayListIndexExpr - root # index
type ArrayListIndexExpr struct {
	Root  Expression
	Index Expression
}

// VarAssignExpr - variable assignment statement
// assign <TargetExpr> from <AssignExpr>
//
// i.e.
// TargetExpr := AssignExpr
type VarAssignExpr struct {
	TargetVar  *ID
	AssignExpr Expression
}

// FuncCallExpr - function call
type FuncCallExpr struct {
	FuncName *ID
	Params   []Expression
}

// LogicType - define several logic type (OR, AND, EQ, etc)
type LogicType uint8

// declare some logic types
const (
	LogicOR  LogicType = 1  // 或
	LogicAND LogicType = 2  // 且
	LogicIS  LogicType = 3  // 此 ... 为 ...
	LogicEQ  LogicType = 4  // 等于
	LogicNEQ LogicType = 5  // 不等于
	LogicGT  LogicType = 6  // 大于
	LogicGTE LogicType = 7  // 不小于
	LogicLT  LogicType = 8  // 小于
	LogicLTE LogicType = 9  // 不大于
	LogicISN LogicType = 10 // 此 ... 不为 ...
)

// LogicExpr - logical expression return TRUE (真) or FALSE (假) only
type LogicExpr struct {
	Type      LogicType
	LeftExpr  Expression
	RightExpr Expression
}

// implement expression interface

// SetLiteral - set literal for primeExpr
func (pe *PrimeExpr) SetLiteral(literal []rune) { pe.Literal = string(literal) }

// GetLiteral -
func (pe *PrimeExpr) GetLiteral() string { return pe.Literal }

func (pe *PrimeExpr) exprNode() {}
func (pe *PrimeExpr) stmtNode() {}

func (le *LogicExpr) exprNode() {}
func (le *LogicExpr) stmtNode() {}

func (va *VarAssignExpr) exprNode() {}
func (va *VarAssignExpr) stmtNode() {}

func (fc *FuncCallExpr) exprNode() {}
func (fc *FuncCallExpr) stmtNode() {}

func (ar *ArrayExpr) exprNode() {}
func (ar *ArrayExpr) stmtNode() {}
func (ar *ArrayExpr) mapList()  {} // belongs to unionMapList

func (ar *HashMapExpr) exprNode() {}
func (ar *HashMapExpr) stmtNode() {}
func (ar *HashMapExpr) mapList()  {} // belongs to unionMapList

func (ai *ArrayListIndexExpr) exprNode() {}
func (ai *ArrayListIndexExpr) stmtNode() {}

//////// Parse Methods

// ParseStatement - a program consists of statements
//
// CFG:
// Statement -> VarDeclareStmt
//           -> BranchStmt
//           -> Expr
//           -> ；
func ParseStatement(p *Parser) (Statement, *error.Error) {
	var validTypes = []lex.TokenType{
		lex.TypeStmtSep,
		lex.TypeComment,
		lex.TypeDeclareW,
		lex.TypeCondW,
		lex.TypeWhileLoopW,
	}
	match, tk := p.tryConsume(validTypes)
	if match {
		switch tk.Type {
		case lex.TypeStmtSep, lex.TypeComment:
			// skip them because it's meaningless for syntax parsing
			return new(EmptyStmt), nil
		case lex.TypeDeclareW:
			return ParseVarDeclareStmt(p)
		case lex.TypeCondW:
			mainIndent := p.getPeekIndent()
			return ParseBranchStmt(p, mainIndent)
		case lex.TypeWhileLoopW:
			return ParseWhileLoopStmt(p)
		}
	}
	// other case, parse expression
	return ParseExpression(p)
}

// ParseExpression - parse an expression, see the following CFG for details
//
// CFG:
// Expr  -> AndE Expr'
// Expr' -> 或 AndE Expr'
//       ->
//
// AndE  -> EqE AndE'
// AndE' -> 且 EqE AndE'
//       ->
//
// EqE   -> VaE EqE'
// EqE'  -> 等于 VaE
//       -> 不等于 VaE
//       -> 小于 VaE
//       -> 不小于 VaE
//       -> 大于 VaE
//       -> 不大于 VaE
//       ->
//
// VaE   -> IdxE VaE'
// VaE'  -> 为 IdxE
//       ->
//
// IdxE  -> BsE IdxE'
// IdxE' -> #  Number   IdxE'
// IdxE' -> #  String   IdxE'
//       -> #{  Expr  }  IdxE'
//
// precedences:
//
// # #{}  >  为  >  等于，大于，etc.  >  且  >  或
func ParseExpression(p *Parser) (Expression, *error.Error) {
	var logicItemParser func(int) (Expression, *error.Error)
	var logicItemTailParser func(int, Expression) (Expression, *error.Error)
	// logicKeywords, ordered by precedence asc
	// that means, the very begin logicKeyword ([]lex.TokenType) has lowest precedence
	var logicKeywords = [4][]lex.TokenType{
		{lex.TypeLogicOrW},
		{lex.TypeLogicAndW},
		{
			lex.TypeLogicEqualW,
			lex.TypeLogicNotEqW,
			lex.TypeLogicGtW,
			lex.TypeLogicGteW,
			lex.TypeLogicLtW,
			lex.TypeLogicLteW,
		},
		{lex.TypeLogicYesW}, // notice: this represents for Variable Assignment!
	}
	var logicTypeMap = map[lex.TokenType]LogicType{
		lex.TypeLogicOrW:    LogicOR,
		lex.TypeLogicAndW:   LogicAND,
		lex.TypeLogicEqualW: LogicEQ,
		lex.TypeLogicNotEqW: LogicNEQ,
		lex.TypeLogicGtW:    LogicGT,
		lex.TypeLogicGteW:   LogicGTE,
		lex.TypeLogicLtW:    LogicLT,
		lex.TypeLogicLteW:   LogicLTE,
	}
	var logicAllowTails = [4]bool{true, true, false, false}

	//// anynomous function definition
	logicItemParser = func(idx int) (Expression, *error.Error) {
		if idx >= len(logicKeywords) {
			return ParseArrayListIndexExpr(p)
		}
		// #1. match item
		expr1, err := logicItemParser(idx + 1)
		if err != nil {
			return nil, err
		}
		return logicItemTailParser(idx, expr1)
	}

	//// anynomous function definition
	logicItemTailParser = func(idx int, leftExpr Expression) (Expression, *error.Error) {
		var finalExpr Expression
		// #1. consume keyword
		match, tk := p.tryConsume(logicKeywords[idx])
		if !match {
			return leftExpr, nil
		}
		// #2. consume Y
		rightExpr, err := logicItemParser(idx + 1)
		if err != nil {
			return nil, err
		}
		// compose logic expr
		if tk.Type == lex.TypeLogicYesW {
			vid, ok := leftExpr.(*ID)
			if !ok {
				return nil, error.ExprMustTypeID()
			}
			finalExpr = &VarAssignExpr{
				TargetVar:  vid,
				AssignExpr: rightExpr,
			}
		} else {
			finalExpr = &LogicExpr{
				Type:      logicTypeMap[tk.Type],
				LeftExpr:  leftExpr,
				RightExpr: rightExpr,
			}
		}
		// #3. consume X' (X-tail)
		if logicAllowTails[idx] {
			return logicItemTailParser(idx, finalExpr)
		}
		return finalExpr, nil
	}

	return logicItemParser(0)
}

// ParseArrayListIndexExpr -
//
// CFG:
//
// IdxE  -> BsE IdxE'
// IdxE' -> #  Number   IdxE'
// IdxE' -> #  String   IdxE'
//       -> #{  Expr  }  IdxE'
//       ->
func ParseArrayListIndexExpr(p *Parser) (Expression, *error.Error) {
	var arrayListTailParser func(Expression) (Expression, *error.Error)
	var hashTypes = []lex.TokenType{
		lex.TypeMapHash,
		lex.TypeMapQHash,
	}

	arrayListTailParser = func(expr Expression) (Expression, *error.Error) {
		idxExpr := &ArrayListIndexExpr{}

		// #1. match hash mark
		match, tk := p.tryConsume(hashTypes)
		if !match {
			return expr, nil
		}

		switch tk.Type {
		case lex.TypeMapHash:
			idxExpr.Root = expr
			// parse Number or String
			tkIdx := p.peek()
			if tkIdx.Type == lex.TypeNumber {
				nexpr := new(Number)
				nexpr.SetLiteral(tkIdx.Literal)
				idxExpr.Index = nexpr
				p.next()
			} else if tkIdx.Type == lex.TypeString {
				sexpr := new(String)
				sexpr.SetLiteral(tkIdx.Literal)
				idxExpr.Index = sexpr
				p.next()
			} else {
				return nil, error.InvalidSyntax()
			}
			return arrayListTailParser(idxExpr)
		default: // lex.TypeMapQHash
			// #1. parse Expr
			nexpr, err := ParseExpression(p)
			if err != nil {
				return nil, err
			}
			idxExpr.Index = nexpr
			// #2. parse tail brace
			if err := p.consume(lex.TypeStmtQuoteR); err != nil {
				return nil, err
			}
			return arrayListTailParser(idxExpr)
		}
	}

	// #1. parse BasicExpr
	rootExpr, err := ParseBasicExpr(p)
	if err != nil {
		return nil, err
	}
	// #2. parse IdxE'
	return arrayListTailParser(rootExpr)
}

// ParseBasicExpr - parse general basic expression
//
// CFG:
// BsE   -> { E }
//       -> （ ID ： E，E，...）
//       -> 此 BsE 为 BsE
//       -> 此 BsE 不为 BsE
//       -> ID
//       -> Number
//       -> String
//       -> ArrayList
func ParseBasicExpr(p *Parser) (Expression, *error.Error) {
	var validTypes = []lex.TokenType{
		lex.TypeIdentifier,
		lex.TypeVarQuote,
		lex.TypeNumber,
		lex.TypeString,
		lex.TypeArrayQuoteL,
		lex.TypeStmtQuoteL,
		lex.TypeFuncQuoteL,
		lex.TypeObjSelfW,
		lex.TypeLogicNotW,
	}

	match, tk := p.tryConsume(validTypes)
	if match {
		switch tk.Type {
		case lex.TypeIdentifier, lex.TypeVarQuote:
			expr := new(ID)
			expr.SetLiteral(tk.Literal)
			return expr, nil
		case lex.TypeNumber:
			expr := new(Number)
			expr.SetLiteral(tk.Literal)
			return expr, nil
		case lex.TypeString:
			expr := new(String)
			expr.SetLiteral(tk.Literal)
			return expr, nil
		case lex.TypeArrayQuoteL:
			return ParseArrayExpr(p)
		case lex.TypeStmtQuoteL:
			expr, err := ParseExpression(p)
			if err != nil {
				return nil, err
			}
			if err := p.consume(lex.TypeStmtQuoteR); err != nil {
				return nil, err
			}
			return expr, nil
		case lex.TypeFuncQuoteL:
			return ParseFuncCallExpr(p)
		case lex.TypeObjSelfW:
			return ParseLogicISExpr(p)
		}
	}
	return nil, error.InvalidSyntax()
}

// ParseArrayExpr - yield ArrayExpr node (support both hashMap and arrayList)
// CFG:
// ArrayExpr -> 【 ItemList 】
//           -> 【】
//           -> 【 HashMapList 】
//           -> 【 == 】
// ItemList  -> Expr ExprTail
//           ->
// ExprTail  -> ， Expr ExprTail
//           ->
// HashMapList -> Expr == Expr， Expr2 == Expr2， ...
func ParseArrayExpr(p *Parser) (unionMapList, *error.Error) {
	// #0. try to match if empty
	match, emptyExpr, err := tryParseEmptyMapList(p)
	if err != nil {
		return nil, err
	}
	if match {
		return emptyExpr, nil
	}

	const (
		tagHashMap     = 11
		subtypeUnknown = 0
		subtypeArray   = 1
		subtypeHashMap = 2
	)
	// #1. consume item list (comma list)
	exprs, err := parseCommaList(p, func(idx int, nodes []Node) (Node, *error.Error) {
		expr, e1 := ParseExpression(p)
		if e1 != nil {
			return nil, e1
		}
		// parse if there's double equals, then cont'd parsing right expr for hashmap
		if match, _ := p.tryConsume([]lex.TokenType{lex.TypeMapData}); match {
			exprR, e2 := ParseExpression(p)
			if e2 != nil {
				return nil, e2
			}
			return &NodeList{
				Tag:      tagHashMap,
				Children: []Node{expr, exprR},
			}, nil
		}
		return expr, nil
	})
	if err != nil {
		return nil, err
	}

	// type cast (because there's no GENERIC TYPE in golang!!!)
	var ar = &ArrayExpr{
		Items: []Expression{},
	}
	var hm = &HashMapExpr{
		KVPair: []HashMapKeyValuePair{},
	}
	var subtype = subtypeUnknown
	for _, expr := range exprs {
		switch v := expr.(type) {
		case Expression:
			if subtype == subtypeUnknown {
				subtype = subtypeArray
			}
			if subtype != subtypeArray {
				return nil, error.NewErrorSLOT("inconsistent array item")
			}
			// add value
			ar.Items = append(ar.Items, v)
		case *NodeList: // tagHashMap
			if subtype == subtypeUnknown {
				subtype = subtypeHashMap
			}
			if subtype != subtypeHashMap {
				return nil, error.NewErrorSLOT("inconsistent array item")
			}
			n0, _ := v.Children[0].(Expression)
			n1, _ := v.Children[1].(Expression)
			hm.KVPair = append(hm.KVPair, HashMapKeyValuePair{
				Key:   n0,
				Value: n1,
			})
		}
	}

	// #2. consume right brancket
	if err := p.consume(lex.TypeArrayQuoteR); err != nil {
		return nil, err
	}
	// #3. return value
	if subtype == subtypeArray {
		return ar, nil
	}
	return hm, nil
}

func tryParseEmptyMapList(p *Parser) (bool, unionMapList, *error.Error) {
	emptyTrialTypes := []lex.TokenType{
		lex.TypeArrayQuoteR, // for empty array
		lex.TypeMapData,     // for empty hashmap
	}

	if match, tk := p.tryConsume(emptyTrialTypes); match {
		switch tk.Type {
		case lex.TypeArrayQuoteR:
			return true, &ArrayExpr{Items: []Expression{}}, nil
		case lex.TypeMapData:
			if err := p.consume(lex.TypeArrayQuoteR); err != nil {
				return false, nil, err
			}
			return true, &HashMapExpr{KVPair: []HashMapKeyValuePair{}}, nil
		}
	}
	return false, nil, nil
}

// ParseFuncCallExpr - yield FuncCallExpr node
//
// CFG:
// FuncCallExpr  -> （ ID ： commaList ）
// commaList     -> E commaListTail
// commaListTail -> ， E commaListTail
//               ->
func ParseFuncCallExpr(p *Parser) (*FuncCallExpr, *error.Error) {
	var callExpr = &FuncCallExpr{
		Params: []Expression{},
	}
	var validIDKeywords = []lex.TokenType{
		lex.TypeVarQuote,
		lex.TypeIdentifier,
	}
	// #1. parse ID
	match, tk := p.tryConsume(validIDKeywords)
	if !match {
		return nil, error.InvalidSyntax()
	}
	idExpr := new(ID)
	idExpr.SetLiteral(tk.Literal)
	callExpr.FuncName = idExpr
	// #2. parse colon (maybe there's no params)
	match2, _ := p.tryConsume([]lex.TokenType{lex.TypeFuncCall})
	if match2 {
		// #2.1 parse comma list
		nodes, err := parseCommaList(p, func(idx int, nodes []Node) (Node, *error.Error) {
			return ParseExpression(p)
		})
		if err != nil {
			return nil, err
		}
		// #2.2 translate nodes into params
		for _, node := range nodes {
			v, _ := node.(Expression)
			callExpr.Params = append(callExpr.Params, v)
		}
	}

	// #3. parse right quote
	if err := p.consume(lex.TypeFuncQuoteR); err != nil {
		return nil, err
	}
	return callExpr, nil
}

// ParseLogicISExpr - logic IS 此 ... 为 ...
// CFG:
// LogicIS -> 此 BasicExpr 为 BasicExpr
// LogicIS -> 此 BasicExpr 不为 BasicExpr
func ParseLogicISExpr(p *Parser) (*LogicExpr, *error.Error) {
	var judgeTypes = []lex.TokenType{
		lex.TypeLogicYesW,
		lex.TypeLogicNotW,
	}

	var logicType LogicType
	// #1. parse expr1
	expr1, err := ParseBasicExpr(p)
	if err != nil {
		return nil, err
	}
	// #2. consume LogicYes or LogicNot
	match, tk := p.tryConsume(judgeTypes)
	if !match {
		return nil, error.InvalidSyntax()
	}
	switch tk.Type {
	case lex.TypeLogicYesW:
		logicType = LogicIS
	case lex.TypeLogicNotW:
		logicType = LogicISN
	}
	// #3. parse expr2
	expr2, err := ParseBasicExpr(p)
	if err != nil {
		return nil, err
	}

	return &LogicExpr{
		Type:      logicType,
		LeftExpr:  expr1,
		RightExpr: expr2,
	}, nil
}

// ParseLogicISNExpr - logic ISN 此 ... 不为 ...
// CFG:
// LogicIS -> 此 BasicExpr 为 BasicExpr
func ParseLogicISNExpr(p *Parser) (*LogicExpr, *error.Error) {
	// #1. parse expr1
	expr1, err := ParseBasicExpr(p)
	if err != nil {
		return nil, err
	}
	// #2. consume LogicNot
	if err := p.consume(lex.TypeLogicNotW); err != nil {
		return nil, err
	}
	// #3. parse expr2
	expr2, err := ParseBasicExpr(p)
	if err != nil {
		return nil, err
	}

	return &LogicExpr{
		Type:      LogicISN,
		LeftExpr:  expr1,
		RightExpr: expr2,
	}, nil
}

// ParseVarDeclareStmt - yield VarDeclare node
// CFG:
// VarDeclare -> 令 IdfList 为 Expr
//    IdfList -> I I'
//         I' -> ，I I'
//            ->
//
// or block declaration:
//
// VarDeclare -> 令 ：
//           ...     I1 ， I2，
//           ...     I3 ， I4， I5 ...
func ParseVarDeclareStmt(p *Parser) (*VarDeclareStmt, *error.Error) {
	vNode := &VarDeclareStmt{
		AssignPair: []VDAssignPair{},
	}

	idTypes := []lex.TokenType{
		lex.TypeVarQuote,
		lex.TypeIdentifier,
	}

	const (
		tagWithAssignExpr = 10
	)
	var nodes = []Node{}
	var err *error.Error

	var consumer = func(idx int, nodes []Node) (Node, *error.Error) {
		// subExpr -> ID
		//         -> ID 为 expr
		var idExpr *ID
		// #1. consume ID first
		if match, tk := p.tryConsume(idTypes); match {
			idExpr = new(ID)
			idExpr.SetLiteral(tk.Literal)
		} else {
			return nil, error.InvalidSyntax()
		}

		// #2. consume LogicYes - if not, return ID directly
		if match2, _ := p.tryConsume([]lex.TokenType{lex.TypeLogicYesW}); !match2 {
			return idExpr, nil
		}

		// #3. consume expr
		assignExpr, err2 := ParseExpression(p)
		if err2 != nil {
			return nil, err2
		}
		return &NodeList{
			Tag:      tagWithAssignExpr,
			Children: []Node{idExpr, assignExpr},
		}, nil
	}
	// #01. try to read colon
	// if colon exists -> parse comma list by block
	// if colon not exists -> parse comma list inline
	if match, _ := p.tryConsume([]lex.TokenType{lex.TypeFuncCall}); match {
		expected, blockIndent := p.expectBlockIndent()
		if !expected {
			return nil, error.InvalidSyntax()
		}
		if nodes, err = parseCommaListBlock(p, blockIndent, consumer); err != nil {
			return nil, err
		}
	} else {
		// #02. consume identifier declare list (comma list) inline
		if nodes, err = parseCommaList(p, consumer); err != nil {
			return nil, err
		}
	}

	var idPtrList = []*ID{}
	// to avoid incomplete AssignPair (i.e. only IDs, but no VA part, like 令A，B，C)
	var completeAssignPair = false
	// #03. translate & append nodes to pair
	for _, node := range nodes {
		switch v := node.(type) {
		case *ID:
			completeAssignPair = false
			idPtrList = append(idPtrList, v)
		case *NodeList:
			if v.Tag == tagWithAssignExpr {
				newPair := VDAssignPair{
					Variables: []*ID{},
				}

				firstID, _ := v.Children[0].(*ID)
				idPtrList = append(idPtrList, firstID)
				//
				secondExpr, _ := v.Children[1].(Expression)
				// copy newPair
				newPair.Variables = append(newPair.Variables, idPtrList...)
				newPair.AssignExpr = secondExpr

				// append newPair
				vNode.AssignPair = append(vNode.AssignPair, newPair)
				// clear idPtrList
				idPtrList = []*ID{}
				completeAssignPair = true
			}
		}
	}

	if !completeAssignPair {
		return nil, error.IncompleteStmtCurr()
	}

	return vNode, nil
}

// ParseWhileLoopStmt - yield while loop node
// CFG:
// WhileLoopStmt -> 每当 Expr ：
//               ..     Block
func ParseWhileLoopStmt(p *Parser) (*WhileLoopStmt, *error.Error) {
	// #1. consume expr
	trueExpr, err := ParseExpression(p)
	if err != nil {
		return nil, err
	}
	// #2. parse colon
	if err := p.consume(lex.TypeFuncCall); err != nil {
		return nil, err
	}
	// #3. parse block
	expected, blockIndent := p.expectBlockIndent()
	if !expected {
		return nil, error.InvalidSyntax()
	}
	block, err := ParseBlockStmt(p, blockIndent)
	if err != nil {
		return nil, err
	}

	return &WhileLoopStmt{
		TrueExpr:  trueExpr,
		LoopBlock: block,
	}, nil
}

// ParseBlockStmt - parse all statements inside a block
func ParseBlockStmt(p *Parser, blockIndent int) (*BlockStmt, *error.Error) {
	bStmt := &BlockStmt{
		Children: []Statement{},
	}

	for (p.peek().Type != lex.TypeEOF) && p.getPeekIndent() == blockIndent {
		stmt, err := ParseStatement(p)
		if err != nil {
			return nil, err
		}
		bStmt.Children = append(bStmt.Children, stmt)
	}

	return bStmt, nil
}

// ParseBranchStmt - yield BranchStmt node
// CFG:
// CondStmt -> 如果 IfTrueExpr ：
//         ...     IfTrueBlock
//
//          -> 如果 IfTrueExpr ：
//         ...     IfTrueBlock
//         ... 否则 ：
//         ...     IfFalseBlock
//
//          -> 如果 IfTrueExpr ：
//         ...     IfTrueBlock
//         ... 再如 OtherExpr1 ：
//         ...     OtherBlock1
//         ... 再如 OtherExpr2 ：
//         ...     OtherBlock2
//         ... ....
//             否则 ：
//         ...     IfFalseBlock
func ParseBranchStmt(p *Parser, mainIndent int) (*BranchStmt, *error.Error) {
	var condExpr Expression
	var condBlock *BlockStmt
	var err *error.Error

	var stmt = new(BranchStmt)

	var condKeywords = []lex.TokenType{
		lex.TypeCondElseW,
		lex.TypeCondOtherW,
	}
	// by definition, the first Branch (if-branch) is required,
	// and the 如果 (if) keyword has been consumed before this function call.
	//
	// thus for other branches (like else-branch and elseif-branch),
	// we should consume the corresponding keyword explicitly. (否则，再如)
	const (
		stateInit        = 0
		stateIfBranch    = 1
		stateElseBranch  = 2
		stateOtherBranch = 3
	)
	var hState = stateInit

	for p.peek().Type != lex.TypeEOF {
		// parse header
		switch hState {
		case stateInit:
			hState = stateIfBranch
		case stateIfBranch, stateOtherBranch:
			if p.getPeekIndent() != mainIndent {
				return stmt, nil
			}
			// parse related keywords (如果 expr： , 再如 expr：, 否则：)
			if match, tk := p.tryConsume(condKeywords); match {
				if tk.Type == lex.TypeCondOtherW {
					hState = stateOtherBranch
				} else {
					hState = stateElseBranch
				}
			} else {
				return stmt, nil
			}
		case stateElseBranch:
			if p.getPeekIndent() != mainIndent {
				return stmt, nil
			}
			if match, _ := p.tryConsume([]lex.TokenType{lex.TypeCondElseW}); !match {
				return stmt, nil
			}
		}

		p.setLineMask(modeInline)
		// #1. parse expr
		if hState != stateElseBranch {
			if condExpr, err = ParseExpression(p); err != nil {
				return nil, err
			}
		}

		// #2. parse colon
		if err = p.consume(lex.TypeFuncCall); err != nil {
			return nil, err
		}
		p.unsetLineMask(modeInline)

		// #3. parse block statements
		ok, blockIndent := p.expectBlockIndent()
		if !ok {
			return nil, error.UnexpectedIndent()
		}
		if condBlock, err = ParseBlockStmt(p, blockIndent); err != nil {
			return nil, err
		}

		// #4. fill data
		switch hState {
		case stateIfBranch:
			stmt.IfTrueExpr = condExpr
			stmt.IfTrueBlock = condBlock
		case stateOtherBranch:
			stmt.OtherExprs = append(stmt.OtherExprs, condExpr)
			stmt.OtherBlocks = append(stmt.OtherBlocks, condBlock)
		case stateElseBranch:
			stmt.HasElse = true
			stmt.IfFalseBlock = condBlock
			// only one else-branch is accepted
			return stmt, nil
		}
	}
	return stmt, nil
}

// parse helpers
func parseCommaList(p *Parser, consumer consumerFunc) ([]Node, *error.Error) {
	var node Node
	var err *error.Error
	//
	list := []Node{}

	var sepTypes = []lex.TokenType{
		lex.TypeCommaSep,
	}
	// first item MUST be consumed!
	if node, err = consumer(0, list); err != nil {
		return nil, err
	}
	list = append(list, node)

	// iterate to get value
	for {
		// consume comma
		if match, _ := p.tryConsume(sepTypes); !match {
			// stop parsing immediately
			return list, nil
		}
		if node, err = consumer(len(list), list); err != nil {
			return nil, err
		}
		list = append(list, node)
	}
}

func parseCommaListBlock(p *Parser, blockIndent int, consumer consumerFunc) ([]Node, *error.Error) {
	var node Node
	var err *error.Error
	//
	list := []Node{}

	var sepTypes = []lex.TokenType{
		lex.TypeCommaSep,
	}
	// first token MUST be exactly on the indent
	if p.getPeekIndent() != blockIndent {
		return nil, error.UnexpectedIndent()
	}
	// first item MUST be consumed!
	if node, err = consumer(0, list); err != nil {
		return nil, err
	}
	list = append(list, node)

	// iterate to get value
	for {
		if p.getPeekIndent() != blockIndent {
			return list, nil
		}
		// consume comma
		if match, _ := p.tryConsume(sepTypes); !match {
			// stop parsing immediately
			return list, nil
		}
		if node, err = consumer(len(list), list); err != nil {
			return nil, err
		}
		list = append(list, node)
	}
}
